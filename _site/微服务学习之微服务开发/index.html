<!DOCTYPE html>
<html>
  <head>
  <title>微服务学习之微服务开发! – Hello Programmer ！ – XKZ的博客</title>

      <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="一、微服务之间如何进行通讯
      从通讯协议上来讲可以选择REST API 、RPC、mq
二、如何选择RPC框架
      1、需要考虑I/O 线程调度模型：到底是同步I/O,还是非阻塞的异步I/O  NIO，是长连接还是短连接。是单线程还是多线程
      2、序列化方式：是可读的还是二进制，可读的例如xml/json二进制的就是一种不可见的例如jdk自带的序列化就是二进制的。序列化的方式直接影响了rpc通讯之间的效率。
      3、多语言支持
      4、服务治理：例如是否有服务的发现，服务的监控。
三、流行的RPC框架
      1、Dubbo
      2、Motan
      3、Thrift
四、服务的发现
      服务发现的本质就是让服务的消费者知道服务的提供者的ip和端口号
      传统的服务就是在nginx中将我们的服务的提供者的ip和端口号写死；
      微服务的发现方式有两种一种是客户端的发现一种是服务端的发现，客服端的发现就是客服端通过向注册中心订阅服务，订阅中心返回服务提供者的ip和端口；服务端的发现就是服务注册到注册中心，客户端会访问一个具体的ip和端口，访问一个具有服务发现和负载均衡的服务。这个服务端其实就是维护了注册中心中的服务列表。
五、服务编排
      服务的编排就是为了解决微服务的发现、部署、更新、扩缩容等。
      流行的服务编排工具：Mesos/Docker Swarm/Kubernetes
六、SpringBoot与微服务
      1、SpringBoot的使命：化繁为简
      2、SpringBoot的核心功能：
      独立运行：传统的Spring项目的运行是通过一个web服务器，例如：TomcatSpringBoot是通过一个java命令将服务运行起来，是通过 java -jar xxx.jar是将服务以一个jar包的形式运行起来；
      内嵌web服务器：SpringBoot内嵌了一个web服务器例如：tomcat，通过将web服务器和应用的包都打到一起并协调位置，他们之间的目录的读取关系，使我们不用关心细节，只需要运行一个命令就可以启动服务。
      简化配置：尽可能的自动化配置Spring
      准生产的应用监控：
      3、SpringBoot与微服务的关系
      java的润滑剂
七、SpringCloud与微服务
      1、Springcloud的使命：简化java的分布式系统
      2、深入理解：Springcloud是一系列框架的集合。springcloud是利用springboot的简化能力来简化分布式系统的基础服务的开发。
      2、SpringBoot意在简化，是一种开发、配置的风格。springcloud是意在简化分布式，是功能的统一，风格的统一。
      3、SpringCloud和微服务的关心：java的微服务。是一种微服务的解决方案，但并不是完整的方案，是偏向微服务的开发，没有提供服务的管理和治理等。侧重开发侧重功能。
      4、SpringCloud核心组件
      Netflix Eureka 服务发现组件

      Netflix Ribbon 客户端负载均衡组件

      Netflix Hystrix 断路器

      Netflix Zuul 服务网关

      SpringCloud Config 分布式配置


" />
    <meta property="og:description" content="一、微服务之间如何进行通讯
      从通讯协议上来讲可以选择REST API 、RPC、mq
二、如何选择RPC框架
      1、需要考虑I/O 线程调度模型：到底是同步I/O,还是非阻塞的异步I/O  NIO，是长连接还是短连接。是单线程还是多线程
      2、序列化方式：是可读的还是二进制，可读的例如xml/json二进制的就是一种不可见的例如jdk自带的序列化就是二进制的。序列化的方式直接影响了rpc通讯之间的效率。
      3、多语言支持
      4、服务治理：例如是否有服务的发现，服务的监控。
三、流行的RPC框架
      1、Dubbo
      2、Motan
      3、Thrift
四、服务的发现
      服务发现的本质就是让服务的消费者知道服务的提供者的ip和端口号
      传统的服务就是在nginx中将我们的服务的提供者的ip和端口号写死；
      微服务的发现方式有两种一种是客户端的发现一种是服务端的发现，客服端的发现就是客服端通过向注册中心订阅服务，订阅中心返回服务提供者的ip和端口；服务端的发现就是服务注册到注册中心，客户端会访问一个具体的ip和端口，访问一个具有服务发现和负载均衡的服务。这个服务端其实就是维护了注册中心中的服务列表。
五、服务编排
      服务的编排就是为了解决微服务的发现、部署、更新、扩缩容等。
      流行的服务编排工具：Mesos/Docker Swarm/Kubernetes
六、SpringBoot与微服务
      1、SpringBoot的使命：化繁为简
      2、SpringBoot的核心功能：
      独立运行：传统的Spring项目的运行是通过一个web服务器，例如：TomcatSpringBoot是通过一个java命令将服务运行起来，是通过 java -jar xxx.jar是将服务以一个jar包的形式运行起来；
      内嵌web服务器：SpringBoot内嵌了一个web服务器例如：tomcat，通过将web服务器和应用的包都打到一起并协调位置，他们之间的目录的读取关系，使我们不用关心细节，只需要运行一个命令就可以启动服务。
      简化配置：尽可能的自动化配置Spring
      准生产的应用监控：
      3、SpringBoot与微服务的关系
      java的润滑剂
七、SpringCloud与微服务
      1、Springcloud的使命：简化java的分布式系统
      2、深入理解：Springcloud是一系列框架的集合。springcloud是利用springboot的简化能力来简化分布式系统的基础服务的开发。
      2、SpringBoot意在简化，是一种开发、配置的风格。springcloud是意在简化分布式，是功能的统一，风格的统一。
      3、SpringCloud和微服务的关心：java的微服务。是一种微服务的解决方案，但并不是完整的方案，是偏向微服务的开发，没有提供服务的管理和治理等。侧重开发侧重功能。
      4、SpringCloud核心组件
      Netflix Eureka 服务发现组件

      Netflix Ribbon 客户端负载均衡组件

      Netflix Hystrix 断路器

      Netflix Zuul 服务网关

      SpringCloud Config 分布式配置


" />
    
    <meta name="author" content="Hello Programmer ！" />

    
    <meta property="og:title" content="微服务学习之微服务开发!" />
    <meta property="twitter:title" content="微服务学习之微服务开发!" />
    
  <!-- Async font loading -->
<script>
  window.WebFontConfig = {
      custom: {
          families: ['Spoqa Han Sans:100,300,400,700'],
          urls: ['https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css']
      },
      timeout: 60000
  };
  (function(d) {
      var wf = d.createElement('script'), s = d.scripts[0];
      wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js';
      s.parentNode.insertBefore(wf, s);
  })(document);
</script>

  <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link rel="stylesheet" type="text/css" href="/HelloProgrammer/style.css" />
  <link rel="alternate" type="application/rss+xml" title="Hello Programmer ！ - XKZ的博客" href="/HelloProgrammer/feed.xml" />
  <link rel="shortcut icon" href="https://xukaizhong188.github.io/HelloProgrammer/images/favicon.png">
  <script src="https://kit.fontawesome.com/56f7faf3f4.js"></script>


  <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->

</head>
  <body>
    <div class="wrapper-sidebar">
  <header class="sidebar clearfix">
    <div class="site-info">
      
        <a href="/HelloProgrammer/" class="site-avatar"><img src="https://xukaizhong188.github.io/HelloProgrammer/images/logo.png" /></a>
       
      <h1 class="site-name"><a href="/HelloProgrammer/">Hello Programmer ！</a></h1>
      <p class="site-description">XKZ的博客</p>
    </div>
  </header>

  <div class="navlist">
    <nav>
      
      
      <a href="/HelloProgrammer/">首页</a>
      
      
      
      <a href="/HelloProgrammer/about">关于</a>
      
      
      
      <a href="/HelloProgrammer/archive">归档</a>
      
      
      
      <a href="/HelloProgrammer/tags">分类</a>
      
      
    </nav>
  </div>

  <div class="wrapper-footer-desktop">
    <footer class="footer">
      <!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  
  
  

  

  

  

  

  

  

  

  

  

  

  

  

  

</ul>



<p>Copyright (c) 2018 XKZ</p>

    </footer>
  </div>
</div>

    <div id="main" role="main" class="wrapper-content">
      <article class="posts">
  <h1>微服务学习之微服务开发!</h1>

  <div clsss="meta">
    <span class="date">
      2018-09-08
    </span>

    <ul class="tag">
      
      <li>
        <a href="http://localhost:4000/HelloProgrammer/tags#微服务">
          微服务
        </a>
      </li>
      
    </ul>
  </div>

  <div class="entry">
    <h2>一、微服务之间如何进行通讯</h2>
<p>      从通讯协议上来讲可以选择REST API 、RPC、mq</p>
<h2>二、如何选择RPC框架</h2>
<p><br />      1、需要考虑I/O 线程调度模型：到底是同步I/O,还是非阻塞的异步I/O  NIO，是长连接还是短连接。是单线程还是多线程
<br />      2、序列化方式：是可读的还是二进制，可读的例如xml/json二进制的就是一种不可见的例如jdk自带的序列化就是二进制的。序列化的方式直接影响了rpc通讯之间的效率。
<br />      3、多语言支持
<br />      4、服务治理：例如是否有服务的发现，服务的监控。</p>
<h2>三、流行的RPC框架</h2>
<p><br />      1、Dubbo
<br />      2、Motan
<br />      3、Thrift</p>
<h2>四、服务的发现</h2>
<p><br />      服务发现的本质就是让服务的消费者知道服务的提供者的ip和端口号
<br />      传统的服务就是在nginx中将我们的服务的提供者的ip和端口号写死；
<br />      微服务的发现方式有两种一种是客户端的发现一种是服务端的发现，客服端的发现就是客服端通过向注册中心订阅服务，订阅中心返回服务提供者的ip和端口；服务端的发现就是服务注册到注册中心，客户端会访问一个具体的ip和端口，访问一个具有服务发现和负载均衡的服务。这个服务端其实就是维护了注册中心中的服务列表。</p>
<h2>五、服务编排</h2>
<p><br />      服务的编排就是为了解决微服务的发现、部署、更新、扩缩容等。
<br />      流行的服务编排工具：Mesos/Docker Swarm/Kubernetes</p>
<h2>六、SpringBoot与微服务</h2>
<p><br />      1、SpringBoot的使命：化繁为简
<br />      2、SpringBoot的核心功能：
<br />      独立运行：传统的Spring项目的运行是通过一个web服务器，例如：TomcatSpringBoot是通过一个java命令将服务运行起来，是通过 java -jar xxx.jar是将服务以一个jar包的形式运行起来；
<br />      内嵌web服务器：SpringBoot内嵌了一个web服务器例如：tomcat，通过将web服务器和应用的包都打到一起并协调位置，他们之间的目录的读取关系，使我们不用关心细节，只需要运行一个命令就可以启动服务。
<br />      简化配置：尽可能的自动化配置Spring
<br />      准生产的应用监控：
<br />      3、SpringBoot与微服务的关系
<br />      java的润滑剂</p>
<h2>七、SpringCloud与微服务</h2>
<p><br />      1、Springcloud的使命：简化java的分布式系统
<br />      2、深入理解：Springcloud是一系列框架的集合。springcloud是利用springboot的简化能力来简化分布式系统的基础服务的开发。
<br />      2、SpringBoot意在简化，是一种开发、配置的风格。springcloud是意在简化分布式，是功能的统一，风格的统一。
<br />      3、SpringCloud和微服务的关心：java的微服务。是一种微服务的解决方案，但并不是完整的方案，是偏向微服务的开发，没有提供服务的管理和治理等。侧重开发侧重功能。
<br />      4、SpringCloud核心组件
<br />      Netflix Eureka 服务发现组件
<img src="https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/2018-09-08/pic1.jpg" alt="img" />
<br />      Netflix Ribbon 客户端负载均衡组件
<img src="https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/2018-09-08/pic2.jpg" alt="img" />
<br />      Netflix Hystrix 断路器
<img src="https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/2018-09-08/pic3.jpg" alt="img" />
<br />      Netflix Zuul 服务网关
<img src="https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/2018-09-08/pic4.jpg" alt="img" />
<br />      SpringCloud Config 分布式配置
<img src="https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/2018-09-08/pic5.jpg" alt="img" /></p>


  </div>

  
</article>

<div class="pagination">
  
    <span class="prev" >
      <a href="http://localhost:4000/HelloProgrammer/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/">
        ← 上一篇
      </a>
    </span>
  
  
    <span class="next" >
      <a href="http://localhost:4000/HelloProgrammer/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">
        下一篇 →
      </a>
    </span>
  
</div>
    </div>

    

  </body>

  <div class="wrapper-footer-mobile">
    <footer class="footer">
      <!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  
  
  

  

  

  

  

  

  

  

  

  

  

  

  

  

</ul>



<p>Copyright (c) 2018 XKZ</p>

    </footer>


</html>
