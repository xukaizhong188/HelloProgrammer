<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.3">Jekyll</generator><link href="http://localhost:4000/HelloProgrammer/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/HelloProgrammer/" rel="alternate" type="text/html" /><updated>2019-07-26T14:37:35+08:00</updated><id>http://localhost:4000/HelloProgrammer/</id><title type="html">Hello Programmer ！</title><subtitle>XKZ的博客</subtitle><entry><title type="html">Spring之AOP一！</title><link href="http://localhost:4000/HelloProgrammer/Spring%E4%B9%8BAOP/" rel="alternate" type="text/html" title="Spring之AOP一！" /><published>2019-07-10T00:00:00+08:00</published><updated>2019-07-10T00:00:00+08:00</updated><id>http://localhost:4000/HelloProgrammer/Spring%E4%B9%8BAOP</id><content type="html" xml:base="http://localhost:4000/HelloProgrammer/Spring%E4%B9%8BAOP/">&lt;h2 id=&quot;核心概念&quot;&gt;核心概念&lt;/h2&gt;

&lt;h3 id=&quot;1横切关注点&quot;&gt;1、横切关注点&lt;/h3&gt;

&lt;p&gt;对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点&lt;/p&gt;

&lt;h3 id=&quot;2切面aspect&quot;&gt;2、切面（aspect）&lt;/h3&gt;

&lt;h2 id=&quot;标题&quot;&gt;标题&lt;/h2&gt;</content><author><name></name></author><category term="spring" /><category term="aop" /><summary type="html">核心概念 1、横切关注点 对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点 2、切面（aspect） 标题</summary></entry><entry><title type="html">Gradlew学习笔记一!</title><link href="http://localhost:4000/HelloProgrammer/Gradlew%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/" rel="alternate" type="text/html" title="Gradlew学习笔记一!" /><published>2019-07-05T00:00:00+08:00</published><updated>2019-07-05T00:00:00+08:00</updated><id>http://localhost:4000/HelloProgrammer/Gradlew%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80</id><content type="html" xml:base="http://localhost:4000/HelloProgrammer/Gradlew%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/">&lt;p&gt;      使用Jekyll搭建博客的详细步骤现在已经很多，所以这里不再赘述，本文主要讲解搭建博客过程中我遇到的一些问题，并提供相应的解决方式，方便大家共同交流，此文处于不断更新中。。。&lt;/p&gt;
&lt;h2&gt;一、搭建起因&lt;/h2&gt;
&lt;p&gt;      作为一名程序员，要学习的东西越来越多，对于刚刚工作的我，着实需要将自己所掌握的和所需要掌握的知识统一进行整理归纳，所以便拥有了搭建一个属于自己的博客的需求。&lt;/p&gt;
&lt;h2&gt;二、前期准备&lt;/h2&gt;
&lt;h3&gt;2.1、搭建博客的技术&lt;/h3&gt;
&lt;p&gt;      目前实现个人博客的建设的方式有很多，对于一些懂技术的大牛来说，完全可以使用JavaWeb实现一个博客，只不过这样的实现方式相对比较麻烦，对技术的要求也比较高。而对技术了解不是很深的小白来说，便需要借助一些工具了。一个个人博客网站，其动态交互相对较少，所以我们可以借助Hexo、Jekyll等来通过解析文章自动生成一些静态页面，然后将这些静态页面托管到服务器上的方式，达到实现个人博客的目的。&lt;/p&gt;
&lt;h3&gt;2.2、GitHub Pages&lt;/h3&gt;
&lt;p&gt;      GitHub Pages是一种静态站点托管服务，旨在直接从GitHub存储库托管您的个人，组织或项目页面。可以直接从您的GitHub存储库托管。只需编辑，推送，您的更改即可生效。其他的用户只需要通过访问相应的域名，便可以直接浏览你的项目。&lt;/p&gt;
&lt;h3&gt;2.3、Jekyll&lt;/h3&gt;
&lt;p&gt;      Jekyll是一个简单的生成静态网站的工具，通过Jekyll,可以将纯文本转化为静态网站和博客。使用Jekyll搭建的博客只需要用到MarkDown或者Textile、Liquid、Html、CSS就可以实现博客的建设，&lt;/p&gt;
&lt;h4&gt;2.4、总结&lt;/h4&gt;
&lt;p&gt;      由于个人在最初对这些博客搭建的技术并不是十分了解，在做了一些了解之后，便开始了自己的搭建之旅。
&lt;br /&gt;
      我将自己的搭建过程整体分为两个步骤，第一步，首先是将博客项目在本地运行起来，这里包括环境的安装、对博客的发布编辑等的熟悉以及本地运行。第二步便是博客的发布，这里主要是将自己本地的项目发布到git上，并通过进行设置，绑定域名等，实现博客的发布。对于第一步，我们主要需要学习的就是jekyll的一些命令、配置、markdown文件的编辑以及最主要的便是项目的开发过程中，各个文件的调用以及解析等。对于博客的发布，这里主要需要关注学习的便是git命令。&lt;/p&gt;
&lt;h2&gt;三、搭建历程&lt;/h2&gt;
&lt;h3&gt;3.1、成果展示&lt;/h3&gt;
&lt;p&gt;      废话不多说，直接上图。
&lt;img src=&quot;https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/pic1.jpg&quot; alt=&quot;img&quot; /&gt;
      出于学习的目的，所以作为博客小白的我决定从零做起，不采用任何主题，后续将更新自己的博客搭建之路，让自己的博客逐渐丰富起来。&lt;/p&gt;
&lt;h3&gt;3.2、开始搭建&lt;/h3&gt;
&lt;p&gt;      对于使用Jekyll搭建博客的教程，现在网上有很多，这里只介绍自己的开发及思考过程，&lt;/p&gt;
&lt;h4&gt;3.2.1、项目分析&lt;/h4&gt;
&lt;p&gt;      作为一名程序员，习惯性的先跑了一个Demo,这个项目便是Jekyll自动生成的博客，接下来便是入口的查找，在对Jekyll项目的文件目录分析，发现Jekyll正常的工程目录为：
&lt;br /&gt;
&lt;br /&gt;      _config.yml Jekyll的配置文件
&lt;br /&gt;      _posts  博客内容
&lt;br /&gt;      _layouts 网页排版模板
&lt;br /&gt;      _includes 被模板包含的HTML片段，可在_config.yml中修改位置
&lt;br /&gt;      assets 辅助资源 css布局 js脚本 图片等
&lt;br /&gt;      _data 动态数据
&lt;br /&gt;      _sites  最终生成的静态网页
&lt;br /&gt;      index.html  博客首页
&lt;br /&gt;
&lt;br /&gt;      而对于一个静态网站，首先我们要有的便是整个网站的整体结构框架，通过编辑_layouts目录下的default.html文件，定义了整个博客的模板框架，其样式布局定义在assets文件下的default.css中。
&lt;img src=&quot;https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/pic2.jpg&quot; width=&quot;100%&quot; height=&quot;50%&quot; /&gt;
&lt;br /&gt;      有了整体的模板布局，接下来便是首页的制定了，通过编辑项目中的index.html文件来编写博客的首页。
&lt;img src=&quot;https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/pic3.jpg&quot; width=&quot;100%&quot; height=&quot;50%&quot; /&gt;
&lt;br /&gt;      完成以上步骤，我们便可以看到自己的博客首页了，接下来我们要做的便是发布自己的博客。我们的博客的编写是在_posts目录下的.markdown文件，这里要注意该这些博客文件的命名规则为xxxx-xxx-xx-xxxxxxx.markdown。里面的具体的语法不在详述。
&lt;br /&gt;      到此，我们的简单的博客变搭建完成，接下来通过，提交到git，便可以发布我们的博客，发布过程不在详述。&lt;/p&gt;
&lt;h3&gt;3.3、遇到的问题&lt;/h3&gt;
&lt;h4&gt;3.3.1、代码提交到git但是无法正常访问，提示404&lt;/h4&gt;
&lt;p&gt;      在一些教程中，当我们将代码提交到git上后，需要我们直接访问一个地址，此时可能会不能如愿，页面提示我们404错误。如图：
&lt;img src=&quot;https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/pic4.jpg&quot; width=&quot;100%&quot; height=&quot;50%&quot; /&gt;
      可以看到提示There isn’t a GitHub Pages site here.这里是说没有GitHub Pags站点，这是因为我们需要主动在git的setting下找到GitHub Pages将Source设置成maseter branch即可。如图:
&lt;img src=&quot;https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/pic5.jpg&quot; width=&quot;100%&quot; height=&quot;50%&quot; /&gt;
&lt;img src=&quot;https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/pic6.jpg&quot; width=&quot;100%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;3.3.2、博客托管到git上，但是样式出现了错误&lt;/h4&gt;
&lt;p&gt;      这类错误主要是样式加载出错造成的，例如：我们通过jekyll生成的本地博客，发布到git上，可能会发现我们的样式出错，通过查看代码可以看到，git上面的样式布局文件等都为空，本地的样式文件也是空，但是在本地查看博客没有问题，这是由于现在的jekyll生成的博客的一些默认配置并不在我们生成的项目文件中，而是在我们的根目录下。在本地解析的时候将会加载这些文件，但是git上并没有这些，所以导致样式出现问题。如果遇到类似的问题，可以详细查看我们的git是否存在要加载的文件，其次我们还要检查代码里面的路径和文件实际路径是否一致。&lt;/p&gt;
&lt;h4&gt;3.3.3、点击博客无法进入访问此网站&lt;/h4&gt;
&lt;p&gt;      在首页中点击我们的博客，提示无法访问此网站.如图
&lt;br /&gt;&lt;img src=&quot;https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/pic7.jpg&quot; width=&quot;50%&quot; height=&quot;25%&quot; /&gt;
&lt;br /&gt;      这样的错误发生在了本地，但是在git上并没有这样的错误。通过比较本地和git的url地址发现，本地地址：http://jekyll/update/2018/…缺少了IP地址和端口号,所以访问不到。这样在我们的首页加载博客地址的a标签，重新修改即可。&lt;/p&gt;
&lt;h4&gt;3.3.4、添加图片&lt;/h4&gt;
&lt;p&gt;      在书写第一篇博客的时，也就是本文，给我最大的困扰之一便是如何在博客文章中插入图片，通过查阅资料可知，MarkDown支持嵌入html标签，那么有了html标签对于插入图片便十分简单了。我们只需要通过以下代码便可插入相应的图片，这里要注意图片的路径问题。
&lt;br /&gt;
&amp;lt; img src=”https://xxx/xxx/xxx/xxjpg” width = “50%” height = “25%”  /&amp;gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h4&gt;3.3.5、文本编辑后样式出现变化&lt;/h4&gt;
&lt;p&gt;      在编写博客的时候，发现自己编写的内容在阅览过程中发生了样式的变化，后来发现，在编辑的时候，多了很多的空格，尤其是开头，删掉空格后问题解决。&lt;/p&gt;</content><author><name></name></author><category term="Gradlew" /><summary type="html">      使用Jekyll搭建博客的详细步骤现在已经很多，所以这里不再赘述，本文主要讲解搭建博客过程中我遇到的一些问题，并提供相应的解决方式，方便大家共同交流，此文处于不断更新中。。。 一、搭建起因       作为一名程序员，要学习的东西越来越多，对于刚刚工作的我，着实需要将自己所掌握的和所需要掌握的知识统一进行整理归纳，所以便拥有了搭建一个属于自己的博客的需求。 二、前期准备 2.1、搭建博客的技术       目前实现个人博客的建设的方式有很多，对于一些懂技术的大牛来说，完全可以使用JavaWeb实现一个博客，只不过这样的实现方式相对比较麻烦，对技术的要求也比较高。而对技术了解不是很深的小白来说，便需要借助一些工具了。一个个人博客网站，其动态交互相对较少，所以我们可以借助Hexo、Jekyll等来通过解析文章自动生成一些静态页面，然后将这些静态页面托管到服务器上的方式，达到实现个人博客的目的。 2.2、GitHub Pages       GitHub Pages是一种静态站点托管服务，旨在直接从GitHub存储库托管您的个人，组织或项目页面。可以直接从您的GitHub存储库托管。只需编辑，推送，您的更改即可生效。其他的用户只需要通过访问相应的域名，便可以直接浏览你的项目。 2.3、Jekyll       Jekyll是一个简单的生成静态网站的工具，通过Jekyll,可以将纯文本转化为静态网站和博客。使用Jekyll搭建的博客只需要用到MarkDown或者Textile、Liquid、Html、CSS就可以实现博客的建设， 2.4、总结       由于个人在最初对这些博客搭建的技术并不是十分了解，在做了一些了解之后，便开始了自己的搭建之旅。       我将自己的搭建过程整体分为两个步骤，第一步，首先是将博客项目在本地运行起来，这里包括环境的安装、对博客的发布编辑等的熟悉以及本地运行。第二步便是博客的发布，这里主要是将自己本地的项目发布到git上，并通过进行设置，绑定域名等，实现博客的发布。对于第一步，我们主要需要学习的就是jekyll的一些命令、配置、markdown文件的编辑以及最主要的便是项目的开发过程中，各个文件的调用以及解析等。对于博客的发布，这里主要需要关注学习的便是git命令。 三、搭建历程 3.1、成果展示       废话不多说，直接上图。       出于学习的目的，所以作为博客小白的我决定从零做起，不采用任何主题，后续将更新自己的博客搭建之路，让自己的博客逐渐丰富起来。 3.2、开始搭建       对于使用Jekyll搭建博客的教程，现在网上有很多，这里只介绍自己的开发及思考过程， 3.2.1、项目分析       作为一名程序员，习惯性的先跑了一个Demo,这个项目便是Jekyll自动生成的博客，接下来便是入口的查找，在对Jekyll项目的文件目录分析，发现Jekyll正常的工程目录为：       _config.yml Jekyll的配置文件       _posts 博客内容       _layouts 网页排版模板       _includes 被模板包含的HTML片段，可在_config.yml中修改位置       assets 辅助资源 css布局 js脚本 图片等       _data 动态数据       _sites 最终生成的静态网页       index.html 博客首页       而对于一个静态网站，首先我们要有的便是整个网站的整体结构框架，通过编辑_layouts目录下的default.html文件，定义了整个博客的模板框架，其样式布局定义在assets文件下的default.css中。       有了整体的模板布局，接下来便是首页的制定了，通过编辑项目中的index.html文件来编写博客的首页。       完成以上步骤，我们便可以看到自己的博客首页了，接下来我们要做的便是发布自己的博客。我们的博客的编写是在_posts目录下的.markdown文件，这里要注意该这些博客文件的命名规则为xxxx-xxx-xx-xxxxxxx.markdown。里面的具体的语法不在详述。       到此，我们的简单的博客变搭建完成，接下来通过，提交到git，便可以发布我们的博客，发布过程不在详述。 3.3、遇到的问题 3.3.1、代码提交到git但是无法正常访问，提示404       在一些教程中，当我们将代码提交到git上后，需要我们直接访问一个地址，此时可能会不能如愿，页面提示我们404错误。如图：       可以看到提示There isn’t a GitHub Pages site here.这里是说没有GitHub Pags站点，这是因为我们需要主动在git的setting下找到GitHub Pages将Source设置成maseter branch即可。如图: 3.3.2、博客托管到git上，但是样式出现了错误       这类错误主要是样式加载出错造成的，例如：我们通过jekyll生成的本地博客，发布到git上，可能会发现我们的样式出错，通过查看代码可以看到，git上面的样式布局文件等都为空，本地的样式文件也是空，但是在本地查看博客没有问题，这是由于现在的jekyll生成的博客的一些默认配置并不在我们生成的项目文件中，而是在我们的根目录下。在本地解析的时候将会加载这些文件，但是git上并没有这些，所以导致样式出现问题。如果遇到类似的问题，可以详细查看我们的git是否存在要加载的文件，其次我们还要检查代码里面的路径和文件实际路径是否一致。 3.3.3、点击博客无法进入访问此网站       在首页中点击我们的博客，提示无法访问此网站.如图       这样的错误发生在了本地，但是在git上并没有这样的错误。通过比较本地和git的url地址发现，本地地址：http://jekyll/update/2018/…缺少了IP地址和端口号,所以访问不到。这样在我们的首页加载博客地址的a标签，重新修改即可。 3.3.4、添加图片       在书写第一篇博客的时，也就是本文，给我最大的困扰之一便是如何在博客文章中插入图片，通过查阅资料可知，MarkDown支持嵌入html标签，那么有了html标签对于插入图片便十分简单了。我们只需要通过以下代码便可插入相应的图片，这里要注意图片的路径问题。 &amp;lt; img src=”https://xxx/xxx/xxx/xxjpg” width = “50%” height = “25%” /&amp;gt; 3.3.5、文本编辑后样式出现变化       在编写博客的时候，发现自己编写的内容在阅览过程中发生了样式的变化，后来发现，在编辑的时候，多了很多的空格，尤其是开头，删掉空格后问题解决。</summary></entry><entry><title type="html">二、JVM内存分配参数!</title><link href="http://localhost:4000/HelloProgrammer/JVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8F%82%E6%95%B0/" rel="alternate" type="text/html" title="二、JVM内存分配参数!" /><published>2019-07-02T00:00:00+08:00</published><updated>2019-07-02T00:00:00+08:00</updated><id>http://localhost:4000/HelloProgrammer/JVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8F%82%E6%95%B0</id><content type="html" xml:base="http://localhost:4000/HelloProgrammer/JVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8F%82%E6%95%B0/">&lt;h1 id=&quot;基本参数&quot;&gt;基本参数&lt;/h1&gt;
&lt;p&gt;设置最大堆内存   -Xmx   例如：-Xmx1M
设置最小堆内存   -Xms  (JVM启动时分配的堆内存，java程序在运行过程中，会先分配这段空间，如果这段空间的内存占满，会再向操作系统申请更多的内存，但不会超过最大内存，如果超出则会抛出内存溢出异常)    -Xms1M
设置新生代大小   -Xmn 用于设置新生代的大小，新生代的大小一般设置为整个堆内存的4分之一或者3分之一
设置新生代初始大小： -XX:NewSize
设置新生代最大值大小  -XX:MaxNewSize
(通常情况下不会对NewSize 和MaxNewSize进行设置，因为这样可能导致内存震荡，从而产生不必要的系统开销)
设置持久代(方法区，不属于堆)最大值  -XX:MaxPermSize
设置持久代(方法区，不属于堆)初始大小  -XX:PermSize
设置线程栈大小  -Xss  java堆也是向操作系统申请空间，所以如果堆设置的太大，会导致操作系统可用线程栈的内存减少，从而减少程序所能支持的程序数量
&lt;img src=&quot;https://xukaizhong188.github.io/HelloProgrammer/images/2019-07-02/image5.png&quot; alt=&quot;img&quot; /&gt;
当系统由于内存不足而无法创建新的线程的时候就会抛出OOM异常&lt;/p&gt;
&lt;h2 id=&quot;堆的比例分配&quot;&gt;堆的比例分配：&lt;/h2&gt;
&lt;p&gt;设置新生代中eden、s0的空间 比例   -XX:SurvivorRatio=8  -XX:SurvivorRatio=eden/s0=eden/s1
设置新生代和老年代的比例   -XX:NewRatio=1  -XX:NewRatio=老年代/新生代
（这些参数在不同版本的jdk中实现可能会有不同，具体可以通过-XX:PrintGCDetails来打印堆的情况来实际设置）&lt;/p&gt;

&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;
&lt;p&gt;设置堆空间最小空闲比例  -XX:MinHeapFreeRatio 当堆空间的空闲内存小于这个数值时，JVM便会扩展堆空间
设置堆空间最大空闲比例  -XX:MaxHeapFreeRatio 当堆空间的空闲内存大于这个数值时，JVM便会压缩堆空间，得到一个较小的堆
设置survivior的可使用率  -XX:TargetSurvivorRatio 当survivor区的空间使用率达到这个数值时，回见对象送入老年代。
&lt;img src=&quot;https://xukaizhong188.github.io/HelloProgrammer/images/2019-07-02/image6.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="JVM" /><summary type="html">基本参数 设置最大堆内存 -Xmx 例如：-Xmx1M 设置最小堆内存 -Xms (JVM启动时分配的堆内存，java程序在运行过程中，会先分配这段空间，如果这段空间的内存占满，会再向操作系统申请更多的内存，但不会超过最大内存，如果超出则会抛出内存溢出异常) -Xms1M 设置新生代大小 -Xmn 用于设置新生代的大小，新生代的大小一般设置为整个堆内存的4分之一或者3分之一 设置新生代初始大小： -XX:NewSize 设置新生代最大值大小 -XX:MaxNewSize (通常情况下不会对NewSize 和MaxNewSize进行设置，因为这样可能导致内存震荡，从而产生不必要的系统开销) 设置持久代(方法区，不属于堆)最大值 -XX:MaxPermSize 设置持久代(方法区，不属于堆)初始大小 -XX:PermSize 设置线程栈大小 -Xss java堆也是向操作系统申请空间，所以如果堆设置的太大，会导致操作系统可用线程栈的内存减少，从而减少程序所能支持的程序数量 当系统由于内存不足而无法创建新的线程的时候就会抛出OOM异常 堆的比例分配： 设置新生代中eden、s0的空间 比例 -XX:SurvivorRatio=8 -XX:SurvivorRatio=eden/s0=eden/s1 设置新生代和老年代的比例 -XX:NewRatio=1 -XX:NewRatio=老年代/新生代 （这些参数在不同版本的jdk中实现可能会有不同，具体可以通过-XX:PrintGCDetails来打印堆的情况来实际设置） 其他 设置堆空间最小空闲比例 -XX:MinHeapFreeRatio 当堆空间的空闲内存小于这个数值时，JVM便会扩展堆空间 设置堆空间最大空闲比例 -XX:MaxHeapFreeRatio 当堆空间的空闲内存大于这个数值时，JVM便会压缩堆空间，得到一个较小的堆 设置survivior的可使用率 -XX:TargetSurvivorRatio 当survivor区的空间使用率达到这个数值时，回见对象送入老年代。</summary></entry><entry><title type="html">一、java内存布局!</title><link href="http://localhost:4000/HelloProgrammer/JVM-Java%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/" rel="alternate" type="text/html" title="一、java内存布局!" /><published>2019-07-01T00:00:00+08:00</published><updated>2019-07-01T00:00:00+08:00</updated><id>http://localhost:4000/HelloProgrammer/JVM-Java%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80</id><content type="html" xml:base="http://localhost:4000/HelloProgrammer/JVM-Java%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/">&lt;h1 id=&quot;java的内存布局&quot;&gt;Java的内存布局&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://xukaizhong188.github.io/HelloProgrammer/images/2019-07-02/image.png&quot; alt=&quot;img&quot; /&gt;
Java虚拟机规范将Java内存布局分为，方法区、堆、Java虚拟机栈、本地方法栈以及程序计数器。其中程序计数器和Java虚拟机栈和本地方栈是线程私有的，方法区和Java堆是线程共享的。&lt;/p&gt;

&lt;h2 id=&quot;1程序计数器&quot;&gt;1.程序计数器：&lt;/h2&gt;
&lt;p&gt;程序计数器指的是线程执行Java方法的行号指示器，如果执行的是Java方法，那么这里面存放的就是Java字节码地址，如果是执行的是本地方法，这里存放的就是null。
程序计数器的内存很小，存在的原因是由于java程序是支持多线程的，如果线程数大于cpu数量的时候，线程之间来回切换争夺cpu资源，所以每一个线程都需要一个独立的程序计数器来记录下一个要运行的指令
对了，这里是Java内存唯一一块没有任何内存溢出的区域。&lt;/p&gt;

&lt;h2 id=&quot;2java虚拟机栈&quot;&gt;2.Java虚拟机栈&lt;/h2&gt;
&lt;p&gt;Java虚拟机栈是Java方法执行的内存模型。它和java线程同时创建。Java每一个方法在执行的时候都会创建一个栈帧来存放局部变量表，操作数栈，动态链接以及方法出口灯信息，每一个方法的执行就对应相应的栈帧出栈入栈的过程。
再说一下局部变量表，局部变量表中存放的是各种基本数据类型、对象的引用（不单单指指针，还有句柄等和Java对象相关联的信息），returnaddress(一条字节码指令的地址)
当线程请求的栈深度大于剩余栈的剩余大小，这里就会抛出stackOverFlowError,如果Java虚拟机栈可以动态扩展，在扩展的时候无法申请到足够的内存也会抛出OutOfMemoryError。
&lt;img src=&quot;https://xukaizhong188.github.io/HelloProgrammer/images/2019-07-02/image1.png&quot; alt=&quot;img&quot; /&gt;
注意：-Xss 可以设置栈的大小。
&lt;img src=&quot;https://xukaizhong188.github.io/HelloProgrammer/images/2019-07-02/image2.png&quot; alt=&quot;img&quot; /&gt;
&lt;img src=&quot;https://xukaizhong188.github.io/HelloProgrammer/images/2019-07-02/image3.png&quot; alt=&quot;img&quot; /&gt;
修改-Xss2M后：
&lt;img src=&quot;https://xukaizhong188.github.io/HelloProgrammer/images/2019-07-02/image4.png&quot; alt=&quot;img&quot; /&gt;
调优相关：在虚拟机栈调优这部分最关键的是 局部变量表，局部变量表存放了方法的入参和局部变量。在运行时，会占用此处内存。
使用jclasslib工具可以查看class文件中每个方法所分配的最大局部变脸表的容量。&lt;/p&gt;
&lt;h2 id=&quot;3本地方法栈&quot;&gt;3.本地方法栈&lt;/h2&gt;
&lt;p&gt;本地方法栈和Java虚拟机栈类似，只不过Java虚拟机栈执行的是Java方法，而本地方法栈执行的native方法。&lt;/p&gt;
&lt;h2 id=&quot;4java堆&quot;&gt;4.Java堆&lt;/h2&gt;
&lt;p&gt;Java堆是Java存放Java对象的实例的地方，是Java内存区域最大的一块，也是垃圾回收的重要区域。
Java堆再Java虚拟机启动的时候创建。主要存放Java对象的实	例。
（后面会详细将Java堆的分类）
如果一个对象无法在Java堆内完成实例的内存分配将会抛出OutOfMemoryError。&lt;/p&gt;
&lt;h2 id=&quot;5方法区&quot;&gt;5.方法区&lt;/h2&gt;
&lt;p&gt;Java的方法区主要存放的是已经被Java虚拟机加载的类的信息、常量、静态变量以及即使编译的代码等数据。这一部分可以不实现Java内存的回收。&lt;/p&gt;
&lt;h2 id=&quot;6运行时常量池&quot;&gt;6.运行时常量池&lt;/h2&gt;
&lt;p&gt;运行时常量池主要存放的是编译时期生成的各种字面量以及符号引用。
这部分会抛出OutOfMemoryError&lt;/p&gt;
&lt;h2 id=&quot;7直接内存&quot;&gt;7.直接内存&lt;/h2&gt;
&lt;p&gt;直接内存不是Java运行时的数据区域，但是也会抛出OutOfMemoryError，Java的NIO可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java队中的DirectByteBuffer对象作为这块内存的引用进行操作。&lt;/p&gt;</content><author><name></name></author><category term="JVM" /><summary type="html">Java的内存布局 Java虚拟机规范将Java内存布局分为，方法区、堆、Java虚拟机栈、本地方法栈以及程序计数器。其中程序计数器和Java虚拟机栈和本地方栈是线程私有的，方法区和Java堆是线程共享的。 1.程序计数器： 程序计数器指的是线程执行Java方法的行号指示器，如果执行的是Java方法，那么这里面存放的就是Java字节码地址，如果是执行的是本地方法，这里存放的就是null。 程序计数器的内存很小，存在的原因是由于java程序是支持多线程的，如果线程数大于cpu数量的时候，线程之间来回切换争夺cpu资源，所以每一个线程都需要一个独立的程序计数器来记录下一个要运行的指令 对了，这里是Java内存唯一一块没有任何内存溢出的区域。 2.Java虚拟机栈 Java虚拟机栈是Java方法执行的内存模型。它和java线程同时创建。Java每一个方法在执行的时候都会创建一个栈帧来存放局部变量表，操作数栈，动态链接以及方法出口灯信息，每一个方法的执行就对应相应的栈帧出栈入栈的过程。 再说一下局部变量表，局部变量表中存放的是各种基本数据类型、对象的引用（不单单指指针，还有句柄等和Java对象相关联的信息），returnaddress(一条字节码指令的地址) 当线程请求的栈深度大于剩余栈的剩余大小，这里就会抛出stackOverFlowError,如果Java虚拟机栈可以动态扩展，在扩展的时候无法申请到足够的内存也会抛出OutOfMemoryError。 注意：-Xss 可以设置栈的大小。 修改-Xss2M后： 调优相关：在虚拟机栈调优这部分最关键的是 局部变量表，局部变量表存放了方法的入参和局部变量。在运行时，会占用此处内存。 使用jclasslib工具可以查看class文件中每个方法所分配的最大局部变脸表的容量。 3.本地方法栈 本地方法栈和Java虚拟机栈类似，只不过Java虚拟机栈执行的是Java方法，而本地方法栈执行的native方法。 4.Java堆 Java堆是Java存放Java对象的实例的地方，是Java内存区域最大的一块，也是垃圾回收的重要区域。 Java堆再Java虚拟机启动的时候创建。主要存放Java对象的实 例。 （后面会详细将Java堆的分类） 如果一个对象无法在Java堆内完成实例的内存分配将会抛出OutOfMemoryError。 5.方法区 Java的方法区主要存放的是已经被Java虚拟机加载的类的信息、常量、静态变量以及即使编译的代码等数据。这一部分可以不实现Java内存的回收。 6.运行时常量池 运行时常量池主要存放的是编译时期生成的各种字面量以及符号引用。 这部分会抛出OutOfMemoryError 7.直接内存 直接内存不是Java运行时的数据区域，但是也会抛出OutOfMemoryError，Java的NIO可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java队中的DirectByteBuffer对象作为这块内存的引用进行操作。</summary></entry><entry><title type="html">NetFlix Conductor源码架构!</title><link href="http://localhost:4000/HelloProgrammer/NetFlix-Conductor%E6%BA%90%E7%A0%81%E6%9E%B6%E6%9E%84/" rel="alternate" type="text/html" title="NetFlix Conductor源码架构!" /><published>2019-07-01T00:00:00+08:00</published><updated>2019-07-01T00:00:00+08:00</updated><id>http://localhost:4000/HelloProgrammer/NetFlix%20Conductor%E6%BA%90%E7%A0%81%E6%9E%B6%E6%9E%84</id><content type="html" xml:base="http://localhost:4000/HelloProgrammer/NetFlix-Conductor%E6%BA%90%E7%A0%81%E6%9E%B6%E6%9E%84/">&lt;p&gt;&lt;img src=&quot;https://xukaizhong188.github.io/HelloProgrammer/images/2019-07-01/pic1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;一、client&lt;/h2&gt;
&lt;p&gt;      和conductor通信的客户端。&lt;/p&gt;
&lt;h2&gt;二、common&lt;/h2&gt;
&lt;p&gt;      主要涉及task任务和workflow工作流的元数据和请求参数定义同时还包括一些工具类。&lt;/p&gt;
&lt;h2&gt;三、core&lt;/h2&gt;
&lt;p&gt;      核心类，包括事件、队列功能类。还包括任务类型定义。每种类型任务的具体实现逻辑和映射关系。&lt;/p&gt;
&lt;h2&gt;四、jersey&lt;/h2&gt;
&lt;p&gt;      主要提供swagger接口展示层，通过启动这个模块来看到接口列表。&lt;/p&gt;
&lt;h2&gt;五、es-persistence&lt;/h2&gt;
&lt;p&gt;      这一层主要是持久层，根据请求版本不同包括es5和es2二个模块，作用主要包括将任务和工作流元数据保存到es中，还有就是将任务运行时数据进行保存，比如任务执行的状态，执行时间等等。&lt;/p&gt;
&lt;h2&gt;六、mysql-persistence&lt;/h2&gt;
&lt;p&gt;      mysql持久层，存储任务和工作流定义的元数据。&lt;/p&gt;
&lt;h2&gt;七、redis-persistence&lt;/h2&gt;
&lt;p&gt;      redis持久层，存储任务和工作流定义的元数据。&lt;/p&gt;
&lt;h2&gt;八、server&lt;/h2&gt;
&lt;p&gt;      负责conductor server端的启动、工作流任务的启动，由server层调用core层实现分布式状态机控制和任务的调度。&lt;/p&gt;
&lt;h2&gt;九、UI&lt;/h2&gt;
&lt;p&gt;      可视化任务管理界面，通过该界面能够看到任务和工作流定义的元数据和图形展现，以及工作流执行的状态情况。&lt;/p&gt;</content><author><name></name></author><category term="Conductor" /><summary type="html">一、client       和conductor通信的客户端。 二、common       主要涉及task任务和workflow工作流的元数据和请求参数定义同时还包括一些工具类。 三、core       核心类，包括事件、队列功能类。还包括任务类型定义。每种类型任务的具体实现逻辑和映射关系。 四、jersey       主要提供swagger接口展示层，通过启动这个模块来看到接口列表。 五、es-persistence       这一层主要是持久层，根据请求版本不同包括es5和es2二个模块，作用主要包括将任务和工作流元数据保存到es中，还有就是将任务运行时数据进行保存，比如任务执行的状态，执行时间等等。 六、mysql-persistence       mysql持久层，存储任务和工作流定义的元数据。 七、redis-persistence       redis持久层，存储任务和工作流定义的元数据。 八、server       负责conductor server端的启动、工作流任务的启动，由server层调用core层实现分布式状态机控制和任务的调度。 九、UI       可视化任务管理界面，通过该界面能够看到任务和工作流定义的元数据和图形展现，以及工作流执行的状态情况。</summary></entry><entry><title type="html">设计模式之简单工厂模式!</title><link href="http://localhost:4000/HelloProgrammer/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" rel="alternate" type="text/html" title="设计模式之简单工厂模式!" /><published>2018-09-20T00:00:00+08:00</published><updated>2018-09-20T00:00:00+08:00</updated><id>http://localhost:4000/HelloProgrammer/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F</id><content type="html" xml:base="http://localhost:4000/HelloProgrammer/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">&lt;p&gt;      很多初学者都会遇到一个问题，对于问题的解决都会直接采用计算机能够理解的逻辑来表述和表达待解决的问题，但是这样的方式只是能够解决当前你问题，程序不容易维护也不容易扩展，更不容易复用。从达不到高质量的代码的效果。活字印刷就是一个很好的例子。通过活字印刷实现了文字的复用。&lt;/p&gt;
&lt;h2&gt;一、面向对象的好处&lt;/h2&gt;
&lt;p&gt;      面向对象的的编程思想就是要让我们通过利用封装、继承、多态把程序的耦合性降低。我们可以通过设计模式来使我们的程序更加的灵活，容易修改并且容易复用。&lt;/p&gt;
&lt;h2&gt;二、简单工厂模式&lt;/h2&gt;
&lt;blockquote&gt;

  &lt;p&gt;&lt;img src=&quot;https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/2018-09-08/pic5.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="设计模式" /><summary type="html">      很多初学者都会遇到一个问题，对于问题的解决都会直接采用计算机能够理解的逻辑来表述和表达待解决的问题，但是这样的方式只是能够解决当前你问题，程序不容易维护也不容易扩展，更不容易复用。从达不到高质量的代码的效果。活字印刷就是一个很好的例子。通过活字印刷实现了文字的复用。 一、面向对象的好处       面向对象的的编程思想就是要让我们通过利用封装、继承、多态把程序的耦合性降低。我们可以通过设计模式来使我们的程序更加的灵活，容易修改并且容易复用。 二、简单工厂模式</summary></entry><entry><title type="html">微服务学习之微服务开发!</title><link href="http://localhost:4000/HelloProgrammer/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/" rel="alternate" type="text/html" title="微服务学习之微服务开发!" /><published>2018-09-08T00:00:00+08:00</published><updated>2018-09-08T00:00:00+08:00</updated><id>http://localhost:4000/HelloProgrammer/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91</id><content type="html" xml:base="http://localhost:4000/HelloProgrammer/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/">&lt;h2&gt;一、微服务之间如何进行通讯&lt;/h2&gt;
&lt;p&gt;      从通讯协议上来讲可以选择REST API 、RPC、mq&lt;/p&gt;
&lt;h2&gt;二、如何选择RPC框架&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;      1、需要考虑I/O 线程调度模型：到底是同步I/O,还是非阻塞的异步I/O  NIO，是长连接还是短连接。是单线程还是多线程
&lt;br /&gt;      2、序列化方式：是可读的还是二进制，可读的例如xml/json二进制的就是一种不可见的例如jdk自带的序列化就是二进制的。序列化的方式直接影响了rpc通讯之间的效率。
&lt;br /&gt;      3、多语言支持
&lt;br /&gt;      4、服务治理：例如是否有服务的发现，服务的监控。&lt;/p&gt;
&lt;h2&gt;三、流行的RPC框架&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;      1、Dubbo
&lt;br /&gt;      2、Motan
&lt;br /&gt;      3、Thrift&lt;/p&gt;
&lt;h2&gt;四、服务的发现&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;      服务发现的本质就是让服务的消费者知道服务的提供者的ip和端口号
&lt;br /&gt;      传统的服务就是在nginx中将我们的服务的提供者的ip和端口号写死；
&lt;br /&gt;      微服务的发现方式有两种一种是客户端的发现一种是服务端的发现，客服端的发现就是客服端通过向注册中心订阅服务，订阅中心返回服务提供者的ip和端口；服务端的发现就是服务注册到注册中心，客户端会访问一个具体的ip和端口，访问一个具有服务发现和负载均衡的服务。这个服务端其实就是维护了注册中心中的服务列表。&lt;/p&gt;
&lt;h2&gt;五、服务编排&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;      服务的编排就是为了解决微服务的发现、部署、更新、扩缩容等。
&lt;br /&gt;      流行的服务编排工具：Mesos/Docker Swarm/Kubernetes&lt;/p&gt;
&lt;h2&gt;六、SpringBoot与微服务&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;      1、SpringBoot的使命：化繁为简
&lt;br /&gt;      2、SpringBoot的核心功能：
&lt;br /&gt;      独立运行：传统的Spring项目的运行是通过一个web服务器，例如：TomcatSpringBoot是通过一个java命令将服务运行起来，是通过 java -jar xxx.jar是将服务以一个jar包的形式运行起来；
&lt;br /&gt;      内嵌web服务器：SpringBoot内嵌了一个web服务器例如：tomcat，通过将web服务器和应用的包都打到一起并协调位置，他们之间的目录的读取关系，使我们不用关心细节，只需要运行一个命令就可以启动服务。
&lt;br /&gt;      简化配置：尽可能的自动化配置Spring
&lt;br /&gt;      准生产的应用监控：
&lt;br /&gt;      3、SpringBoot与微服务的关系
&lt;br /&gt;      java的润滑剂&lt;/p&gt;
&lt;h2&gt;七、SpringCloud与微服务&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;      1、Springcloud的使命：简化java的分布式系统
&lt;br /&gt;      2、深入理解：Springcloud是一系列框架的集合。springcloud是利用springboot的简化能力来简化分布式系统的基础服务的开发。
&lt;br /&gt;      2、SpringBoot意在简化，是一种开发、配置的风格。springcloud是意在简化分布式，是功能的统一，风格的统一。
&lt;br /&gt;      3、SpringCloud和微服务的关心：java的微服务。是一种微服务的解决方案，但并不是完整的方案，是偏向微服务的开发，没有提供服务的管理和治理等。侧重开发侧重功能。
&lt;br /&gt;      4、SpringCloud核心组件
&lt;br /&gt;      Netflix Eureka 服务发现组件
&lt;img src=&quot;https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/2018-09-08/pic1.jpg&quot; alt=&quot;img&quot; /&gt;
&lt;br /&gt;      Netflix Ribbon 客户端负载均衡组件
&lt;img src=&quot;https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/2018-09-08/pic2.jpg&quot; alt=&quot;img&quot; /&gt;
&lt;br /&gt;      Netflix Hystrix 断路器
&lt;img src=&quot;https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/2018-09-08/pic3.jpg&quot; alt=&quot;img&quot; /&gt;
&lt;br /&gt;      Netflix Zuul 服务网关
&lt;img src=&quot;https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/2018-09-08/pic4.jpg&quot; alt=&quot;img&quot; /&gt;
&lt;br /&gt;      SpringCloud Config 分布式配置
&lt;img src=&quot;https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/2018-09-08/pic5.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="微服务" /><summary type="html">一、微服务之间如何进行通讯       从通讯协议上来讲可以选择REST API 、RPC、mq 二、如何选择RPC框架       1、需要考虑I/O 线程调度模型：到底是同步I/O,还是非阻塞的异步I/O NIO，是长连接还是短连接。是单线程还是多线程       2、序列化方式：是可读的还是二进制，可读的例如xml/json二进制的就是一种不可见的例如jdk自带的序列化就是二进制的。序列化的方式直接影响了rpc通讯之间的效率。       3、多语言支持       4、服务治理：例如是否有服务的发现，服务的监控。 三、流行的RPC框架       1、Dubbo       2、Motan       3、Thrift 四、服务的发现       服务发现的本质就是让服务的消费者知道服务的提供者的ip和端口号       传统的服务就是在nginx中将我们的服务的提供者的ip和端口号写死；       微服务的发现方式有两种一种是客户端的发现一种是服务端的发现，客服端的发现就是客服端通过向注册中心订阅服务，订阅中心返回服务提供者的ip和端口；服务端的发现就是服务注册到注册中心，客户端会访问一个具体的ip和端口，访问一个具有服务发现和负载均衡的服务。这个服务端其实就是维护了注册中心中的服务列表。 五、服务编排       服务的编排就是为了解决微服务的发现、部署、更新、扩缩容等。       流行的服务编排工具：Mesos/Docker Swarm/Kubernetes 六、SpringBoot与微服务       1、SpringBoot的使命：化繁为简       2、SpringBoot的核心功能：       独立运行：传统的Spring项目的运行是通过一个web服务器，例如：TomcatSpringBoot是通过一个java命令将服务运行起来，是通过 java -jar xxx.jar是将服务以一个jar包的形式运行起来；       内嵌web服务器：SpringBoot内嵌了一个web服务器例如：tomcat，通过将web服务器和应用的包都打到一起并协调位置，他们之间的目录的读取关系，使我们不用关心细节，只需要运行一个命令就可以启动服务。       简化配置：尽可能的自动化配置Spring       准生产的应用监控：       3、SpringBoot与微服务的关系       java的润滑剂 七、SpringCloud与微服务       1、Springcloud的使命：简化java的分布式系统       2、深入理解：Springcloud是一系列框架的集合。springcloud是利用springboot的简化能力来简化分布式系统的基础服务的开发。       2、SpringBoot意在简化，是一种开发、配置的风格。springcloud是意在简化分布式，是功能的统一，风格的统一。       3、SpringCloud和微服务的关心：java的微服务。是一种微服务的解决方案，但并不是完整的方案，是偏向微服务的开发，没有提供服务的管理和治理等。侧重开发侧重功能。       4、SpringCloud核心组件       Netflix Eureka 服务发现组件       Netflix Ribbon 客户端负载均衡组件       Netflix Hystrix 断路器       Netflix Zuul 服务网关       SpringCloud Config 分布式配置</summary></entry><entry><title type="html">微服务学习之微服务入门!</title><link href="http://localhost:4000/HelloProgrammer/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/" rel="alternate" type="text/html" title="微服务学习之微服务入门!" /><published>2018-09-08T00:00:00+08:00</published><updated>2018-09-08T00:00:00+08:00</updated><id>http://localhost:4000/HelloProgrammer/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8</id><content type="html" xml:base="http://localhost:4000/HelloProgrammer/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/">&lt;h2&gt;一、微服务之间如何进行通讯&lt;/h2&gt;
&lt;p&gt;      从通讯协议上来讲可以选择REST API 、RPC、mq&lt;/p&gt;
&lt;h2&gt;二、如何选择RPC框架&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;      1、需要考虑I/O 线程调度模型：到底是同步I/O,还是非阻塞的异步I/O  NIO，是长连接还是短连接。是单线程还是多线程
&lt;br /&gt;      2、序列化方式：是可读的还是二进制，可读的例如xml/json二进制的就是一种不可见的例如jdk自带的序列化就是二进制的。序列化的方式直接影响了rpc通讯之间的效率。
&lt;br /&gt;      3、多语言支持
&lt;br /&gt;      4、服务治理：例如是否有服务的发现，服务的监控。&lt;/p&gt;
&lt;h2&gt;三、流行的RPC框架&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;      1、Dubbo
&lt;br /&gt;      2、Motan
&lt;br /&gt;      3、Thrift
&lt;br /&gt;      4、Dubbo&lt;/p&gt;
&lt;h2&gt;四、服务的发现&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;      服务发现的本质就是让服务的消费者知道服务的提供者的ip和端口号
&lt;br /&gt;      传统的服务就是在nginx中将我们的服务的提供者的ip和端口号写死；
&lt;br /&gt;      微服务的发现方式有两种一种是客户端的发现一种是服务端的发现，客服端的发现就是客服端通过向注册中心订阅服务，订阅中心返回服务提供者的ip和端口；服务端的发现就是服务注册到注册中心，客户端会访问一个具体的ip和端口，访问一个具有服务发现和负载均衡的服务。这个服务端其实就是维护了注册中心中的服务列表。&lt;/p&gt;
&lt;h2&gt;五、服务编排&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;      服务的编排就是为了解决微服务的发现、部署、更新、扩缩容等。
&lt;br /&gt;      流行的服务编排工具：Mesos/Docker Swarm/Kubernetes&lt;/p&gt;
&lt;h2&gt;六、SpringBoot与微服务&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;      1、SpringBoot的使命：化繁为简
&lt;br /&gt;      2、SpringBoot的核心功能：
&lt;br /&gt;      独立运行：传统的Spring项目的运行是通过一个web服务器，例如：TomcatSpringBoot是通过一个java命令将服务运行起来，是通过 java -jar xxx.jar是将服务以一个jar包的形式运行起来；
&lt;br /&gt;      内嵌web服务器：SpringBoot内嵌了一个web服务器例如：tomcat，通过将web服务器和应用的包都打到一起并协调位置，他们之间的目录的读取关系，使我们不用关心细节，只需要运行一个命令就可以启动服务。
&lt;br /&gt;      简化配置：尽可能的自动化配置Spring
&lt;br /&gt;      准生产的应用监控：
&lt;br /&gt;      3、SpringBoot与微服务的关系
&lt;br /&gt;      java的润滑剂&lt;/p&gt;
&lt;h2&gt;七、SpringCloud与微服务&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;      1、Springcloud的使命：简化java的分布式系统
&lt;br /&gt;      2、深入理解：Springcloud是一系列框架的集合。springcloud是利用springboot的简化能力来简化分布式系统的基础服务的开发。
&lt;br /&gt;      2、SpringBoot意在简化，是一种开发、配置的风格。springcloud是意在简化分布式，是功能的统一，风格的统一。
&lt;br /&gt;      3、SpringCloud和微服务的关心：java的微服务。是一种微服务的解决方案，但并不是完整的方案，是偏向微服务的开发，没有提供服务的管理和治理等。侧重开发侧重功能。
&lt;br /&gt;      4、SpringCloud核心组件
&lt;br /&gt;      Netflix Eureka 服务发现组件
&lt;img src=&quot;https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/2018-09-08/pic1.jpg&quot; alt=&quot;img&quot; /&gt;
&lt;br /&gt;      Netflix Ribbon 客户端负载均衡组件
&lt;img src=&quot;https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/2018-09-08/pic2.jpg&quot; alt=&quot;img&quot; /&gt;
&lt;br /&gt;      Netflix Hystrix 断路器
&lt;img src=&quot;https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/2018-09-08/pic3.jpg&quot; alt=&quot;img&quot; /&gt;
&lt;br /&gt;      Netflix Zuul 服务网关
&lt;img src=&quot;https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/2018-09-08/pic4.jpg&quot; alt=&quot;img&quot; /&gt;
&lt;br /&gt;      SpringCloud Config 分布式配置
&lt;img src=&quot;https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/2018-09-08/pic5.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="微服务" /><summary type="html">一、微服务之间如何进行通讯       从通讯协议上来讲可以选择REST API 、RPC、mq 二、如何选择RPC框架       1、需要考虑I/O 线程调度模型：到底是同步I/O,还是非阻塞的异步I/O NIO，是长连接还是短连接。是单线程还是多线程       2、序列化方式：是可读的还是二进制，可读的例如xml/json二进制的就是一种不可见的例如jdk自带的序列化就是二进制的。序列化的方式直接影响了rpc通讯之间的效率。       3、多语言支持       4、服务治理：例如是否有服务的发现，服务的监控。 三、流行的RPC框架       1、Dubbo       2、Motan       3、Thrift       4、Dubbo 四、服务的发现       服务发现的本质就是让服务的消费者知道服务的提供者的ip和端口号       传统的服务就是在nginx中将我们的服务的提供者的ip和端口号写死；       微服务的发现方式有两种一种是客户端的发现一种是服务端的发现，客服端的发现就是客服端通过向注册中心订阅服务，订阅中心返回服务提供者的ip和端口；服务端的发现就是服务注册到注册中心，客户端会访问一个具体的ip和端口，访问一个具有服务发现和负载均衡的服务。这个服务端其实就是维护了注册中心中的服务列表。 五、服务编排       服务的编排就是为了解决微服务的发现、部署、更新、扩缩容等。       流行的服务编排工具：Mesos/Docker Swarm/Kubernetes 六、SpringBoot与微服务       1、SpringBoot的使命：化繁为简       2、SpringBoot的核心功能：       独立运行：传统的Spring项目的运行是通过一个web服务器，例如：TomcatSpringBoot是通过一个java命令将服务运行起来，是通过 java -jar xxx.jar是将服务以一个jar包的形式运行起来；       内嵌web服务器：SpringBoot内嵌了一个web服务器例如：tomcat，通过将web服务器和应用的包都打到一起并协调位置，他们之间的目录的读取关系，使我们不用关心细节，只需要运行一个命令就可以启动服务。       简化配置：尽可能的自动化配置Spring       准生产的应用监控：       3、SpringBoot与微服务的关系       java的润滑剂 七、SpringCloud与微服务       1、Springcloud的使命：简化java的分布式系统       2、深入理解：Springcloud是一系列框架的集合。springcloud是利用springboot的简化能力来简化分布式系统的基础服务的开发。       2、SpringBoot意在简化，是一种开发、配置的风格。springcloud是意在简化分布式，是功能的统一，风格的统一。       3、SpringCloud和微服务的关心：java的微服务。是一种微服务的解决方案，但并不是完整的方案，是偏向微服务的开发，没有提供服务的管理和治理等。侧重开发侧重功能。       4、SpringCloud核心组件       Netflix Eureka 服务发现组件       Netflix Ribbon 客户端负载均衡组件       Netflix Hystrix 断路器       Netflix Zuul 服务网关       SpringCloud Config 分布式配置</summary></entry><entry><title type="html">NetFlix Conductor学习之官方样例搭建!</title><link href="http://localhost:4000/HelloProgrammer/NetFlix-Conductor%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%98%E6%96%B9%E6%A0%B7%E4%BE%8B%E6%90%AD%E5%BB%BA/" rel="alternate" type="text/html" title="NetFlix Conductor学习之官方样例搭建!" /><published>2018-09-07T00:00:00+08:00</published><updated>2018-09-07T00:00:00+08:00</updated><id>http://localhost:4000/HelloProgrammer/NetFlix%20Conductor%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%98%E6%96%B9%E6%A0%B7%E4%BE%8B%E6%90%AD%E5%BB%BA</id><content type="html" xml:base="http://localhost:4000/HelloProgrammer/NetFlix-Conductor%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%98%E6%96%B9%E6%A0%B7%E4%BE%8B%E6%90%AD%E5%BB%BA/">&lt;p&gt;      这个系列的文章主要是老大让本人学校微服务编排，将之运用到我们现有的一个项目中，由于本人初接触，对其中的一些内容没有深入了解，所以在学习之初，先将官网的样例进行运行。下面就介绍下NetFlix Conductor官方样例搭建过程。&lt;/p&gt;
&lt;h2&gt;一、下载源码&lt;/h2&gt;
&lt;p&gt;      首先我们到NetFlix Conductor的git官网将源码下载下来，下载地址：https://github.com/Netflix/conductor&lt;/p&gt;
&lt;h2&gt;二、安装Swagger API&lt;/h2&gt;
&lt;p&gt;      首先进入到我们的安装路径下，运行ce server 进入server目录，接着运行../gradlew server命令开始安装过程，整个安装过程比较耗时。
&lt;img src=&quot;https://xukaizhong188.github.io/xukaizhong.github.io/assets/postImages/2018-09-07/pic1.jpg&quot; alt=&quot;img&quot; /&gt;
      注意一下：安装UI要求先node.js 8.0以上因为运行glup命令是需要node.js。安装完node.js需要安装gulp
&lt;br /&gt;      安装步骤：
&lt;br /&gt;      执行cd ui 进入ui目录，
&lt;br /&gt;      再执行 gulp watch等待构建完成即可。&lt;/p&gt;</content><author><name></name></author><category term="Conductor" /><summary type="html">      这个系列的文章主要是老大让本人学校微服务编排，将之运用到我们现有的一个项目中，由于本人初接触，对其中的一些内容没有深入了解，所以在学习之初，先将官网的样例进行运行。下面就介绍下NetFlix Conductor官方样例搭建过程。 一、下载源码       首先我们到NetFlix Conductor的git官网将源码下载下来，下载地址：https://github.com/Netflix/conductor 二、安装Swagger API       首先进入到我们的安装路径下，运行ce server 进入server目录，接着运行../gradlew server命令开始安装过程，整个安装过程比较耗时。       注意一下：安装UI要求先node.js 8.0以上因为运行glup命令是需要node.js。安装完node.js需要安装gulp       安装步骤：       执行cd ui 进入ui目录，       再执行 gulp watch等待构建完成即可。</summary></entry><entry><title type="html">Linux学习!</title><link href="http://localhost:4000/HelloProgrammer/LInux%E5%AD%A6%E4%B9%A0/" rel="alternate" type="text/html" title="Linux学习!" /><published>2018-08-26T00:00:00+08:00</published><updated>2018-08-26T00:00:00+08:00</updated><id>http://localhost:4000/HelloProgrammer/LInux%E5%AD%A6%E4%B9%A0</id><content type="html" xml:base="http://localhost:4000/HelloProgrammer/LInux%E5%AD%A6%E4%B9%A0/">&lt;p&gt;      本篇主要记录的是Linux的文件权限和目录配置&lt;/p&gt;
&lt;h2&gt;一、用户与用户组&lt;/h2&gt;
&lt;p&gt;      首先Linux是一个多用户多任务的系统，所以为了考虑安全等方面，文件的所有者的角色就显得尤为重要。
&lt;br /&gt;      用户组的存在是为了将文件共享给团队。
&lt;br /&gt;      
&lt;br /&gt;      
&lt;br /&gt;      
&lt;br /&gt;      &lt;/p&gt;
&lt;h2&gt;二、表达式&lt;/h2&gt;
&lt;p&gt;      1、中缀表达式：java使用的是中缀表达式，也就是一个字面量或者一个表达式，紧接着是一个运算符，再接着是字面量或者是表达式。
&lt;br /&gt;      2、运算符的优先级：*、/、%优先于+、-；！ &amp;gt;  &amp;amp;&amp;amp;  &amp;gt;  ||&lt;/p&gt;
&lt;h2&gt;三、类型转换&lt;/h2&gt;
&lt;p&gt;      1、类型提升：如果不会损失信息，那么数值会被自动提升为更高级的数据类型，例如：1+1.5其中1会类型提升为1.0，所以结果为2.5。
&lt;br /&gt;      2、浮点数转化为整型的时候是采用的截取小数部分，而不是四舍五入。&lt;/p&gt;
&lt;h2&gt;四、原始数据类型&lt;/h2&gt;
&lt;p&gt;      原始的数据类型：
&lt;br /&gt;      1、8位整数：byte
&lt;br /&gt;      2、16位整数：short
&lt;br /&gt;      3、16位字符：char
&lt;br /&gt;      4、32位单精度实数：float
&lt;br /&gt;      5、32位整数：int
&lt;br /&gt;      6、64位双精度实数：double
&lt;br /&gt;      7、布尔类型：boolean&lt;/p&gt;
&lt;h2&gt;四、书写&lt;/h2&gt;
&lt;p&gt;      1、声明并初始化：可以将声明语句和赋值语句相结合，在声明（创建）一个变量的同时将他初始化。
&lt;br /&gt;      2、隐式赋值:递增、递减运算符，复合运算符（i+=1）
&lt;br /&gt;      3、单语句代码段:如果条件或者魂环语句的代码段只有一条语句，可以将代码段的花括号省略&lt;/p&gt;</content><author><name></name></author><category term="Linux" /><summary type="html">      本篇主要记录的是Linux的文件权限和目录配置 一、用户与用户组       首先Linux是一个多用户多任务的系统，所以为了考虑安全等方面，文件的所有者的角色就显得尤为重要。       用户组的存在是为了将文件共享给团队。                             二、表达式       1、中缀表达式：java使用的是中缀表达式，也就是一个字面量或者一个表达式，紧接着是一个运算符，再接着是字面量或者是表达式。       2、运算符的优先级：*、/、%优先于+、-；！ &amp;gt; &amp;amp;&amp;amp; &amp;gt; || 三、类型转换       1、类型提升：如果不会损失信息，那么数值会被自动提升为更高级的数据类型，例如：1+1.5其中1会类型提升为1.0，所以结果为2.5。       2、浮点数转化为整型的时候是采用的截取小数部分，而不是四舍五入。 四、原始数据类型       原始的数据类型：       1、8位整数：byte       2、16位整数：short       3、16位字符：char       4、32位单精度实数：float       5、32位整数：int       6、64位双精度实数：double       7、布尔类型：boolean 四、书写       1、声明并初始化：可以将声明语句和赋值语句相结合，在声明（创建）一个变量的同时将他初始化。       2、隐式赋值:递增、递减运算符，复合运算符（i+=1）       3、单语句代码段:如果条件或者魂环语句的代码段只有一条语句，可以将代码段的花括号省略</summary></entry></feed>