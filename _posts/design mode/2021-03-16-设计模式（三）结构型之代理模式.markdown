---
layout: post
title: 设计模式（三）结构型之代理模式!
date:  2021-03-16
Author: XKZ
categories: jekyll update
tags: [设计模式]
comments: true
---
在现实生活中，有些情况不能够让一个对象去直接访问另外一个对象，这个时候就需要一个中介来完成这项任务，这个就是代理
## 1、模式的定义及特点
由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。
## 2、优缺点
### 优点
代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；   
代理对象可以扩展目标对象的功能；   
代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性   
### 缺点
代理模式会造成系统设计中类的数量增加   
在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；   
增加了系统的复杂度；   
## 3、模式的实现
代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。
抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。

## 4、示例
    //抽象主题
    interface Subject{
        void sendRequest();
    }
    //真实主题
    class RealSubject implements Subject{
        public void sendRequest() {
        System.out.println("发送请求");
        }
    }
    //代理类
    class Proxy implements Subject{
        private RealSubject realSubject;
        public void sendRequest() {
            if (realSubject == null){
                realSubject = new RealSubject();
            }
            bef();
            realSubject.sendRequest();
            aft();
        }
        private void bef(){
            System.out.println("发送请求前。。。。");
        }
        private void aft(){
            System.out.println("发送请求后。。。。");
        }
    }

## 5、代理模式的应用场景

当无法或不想直接引用某个对象或访问某个对象存在困难时，可以通过代理对象来间接访问。使用代理模式主要有两个目的：一是保护目标对象，二是增强目标对象。    
前面分析了代理模式的结构与特点，现在来分析以下的应用场景。   
远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。   
虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。   
安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。   
智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。    
延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。   

[参考：设计模式-代理模式](http://c.biancheng.net/view/1359.html "代理模式").
