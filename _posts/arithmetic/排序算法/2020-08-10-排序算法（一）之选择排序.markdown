---
layout: post
title: 排序算法（一）之选择排序!
date:  2019-08-10
Author: XKZ
categories: jekyll update
tags: [算法,排序算法]
comments: true
---
# 注意
此系列文章默认从小到大排序，源码请查看[源码](https://github.com/xukaizhong188/leetcode "源码")。
# 选择排序
## 一、算法描述
选择排序：首先先找到数组中最小的元素，然后再和数组的第一个位置进行交换，如果第一个元素就是最小，那么和他本身进行交换，然后在选择数组中剩下的元素中最小的元素，再和第二个位置交换，一次类推完成排序。
## 二、特点
### 1、运行时间和输入无关
无论输入的数组是多么的复杂或者是多么简单，程序运行都会为了找到最小的元素而进行扫描，所以程序运行时间是一定的。
### 2、数据移动最少
每次数据的交换都是交换两个元素的位置，所以选择排序会使用n次交换，和数组的大小成线性关系。
## 三、时间复杂度
选择排序的交换操作介于 0 和 (n - 1） 次之间。选择排序的比较操作为 n (n - 1） / 2 次之间。选择排序的赋值操作介于 0 和 3 (n - 1） 次之间。比较次数O(n^2），比较次数与关键字的初始状态无关，总的比较次数N=(n-1）+(n-2）+...+1=n*(n-1）/2。交换次数O(n），最好情况是，已经有序，交换0次；最坏情况交换n-1次，逆序交换n/2次。交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。
## 四、示例
      private int[] sort(int[] numbs) {
         for (int i = 0;i<numbs.length;i++){
             int min =i;
             //比较大小，找到最小值
             for (int j = i+1 ;j<numbs.length;j++){
                 if (numbs[min] >= numbs[j]){
                     min = j;
                 }
             }
             //将最小值min和当前位置进行交换
             int tem = numbs[i];
             numbs[i] = numbs[min];
             numbs[min] = tem;
         }
         return numbs;
     }
