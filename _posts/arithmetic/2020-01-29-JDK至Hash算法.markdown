---
layout: post
title: JDK之HASH算法!
date:  2020-01-29
Author: XKZ
categories: jekyll update
tags: [算法,HASH]
comments: true
---
## HASH
#### 引入：利用数组下标----散列表（哈希表）
例1：给你一个N(1<N<10)个自然数，每个数的范围是1到100，如果以最快的速度判断某一个数是否在这N个数中
（不得使用封装好的类该如何实现）  
方案一：二分查找，二分的前提是有序，所以需要先排序，再查找。  
方案二：排序+查找  
方案三：哈希查找  
````
int[] a = new int[100];//最大值为100
初始数组里面全部为0，利用数组下表来映射我们查找的值，a[10] = 1,a[60] = 1,a[1]=1,a[5]=1
所以只需要初始下表为1的就表示存在。时间复杂度为O(1)
````
#### 散列表（哈希表）
散列表的特性就是利用数组下表的特性，所以散列表就是数组的一种扩展，是有数组演化而来的。  
数组+链表（双向、单向链表）
#### 散列函数（哈希函数）
例1中的散列函数是y=x，就是对N取模。a[10]=1
散列函数也就是我们经常看到的hash(key)，我们通过散列函数来计算散列值。

例2:在例1的基础上加入每个数字的范围在1亿之内，最大值不能初始为100。N为5 分别为10，14，52，63，15判断30是否存在。  
````
int[] a = new int[N] 
对N取余
a[10%10] = a[0] =10 ?为什么不能使用 0 和 1
a[14%10] = a[4] =14
a[52%10] = a[2] =52
a[63%10] = a[3] =63
a[15%10] = a[5] =15 
````
思考1：a[10%10] = a[0] =10 ?为什么不能使用 0 和 1  
假如a[10%10] = a[0] =1的话，那么试想30取余后为a[0]=1,但是实际情况是30并不在这5个数之中。
思考2：碰撞问题。 假如这N个数中有一个20 那么10 和20 取余后都为a[0],此时就产生了哈希碰撞，也叫做哈希冲突。  
*（哈希冲突：通过哈希函数产生的哈希值会存在一致，此时这种情况就是哈希冲突。）*  
如何解决？  
方案一：改变散列函数例如在取余的基础上进行其他操作，但是计算成本比较高，而且还可能存在
方案二:探测方法(线性寻址)  
如果出现哈希冲突，就重新再找一个空闲的位置将其插入。在删除的时候要置为删除标记位  
缺点:  
1、空间问题，需要扩容；  
2、如果哈希冲突比较严重，就变成一条；  
3、删除怎么办？置为标记位
方案三：加链表（链路寻址）哈希map的数据结构  
优点（链表的插入和删除很简单）：  
1、数据使用起来比较简单；  
缺点：  
1、遍历慢；  
如何解决遍历慢的问题？  
修改数据结构，将链表改为树（使用二叉查找树）  

#### 二叉查找树
以根节点为中心，左边的都比他 小，右面的节点都比他大；  