---
layout: post
title: java并发编程实践-基础知识!
date:  2019-09-14
Author: XKZ
categories: jekyll update
tags: [concurrency]
comments: true
---
## 一、线程安全性
在java同步机制中，同步的关键字是synchronized,它提供了一种独占的加锁方式，但是同步术语还包括volatile类型的变量，显式锁（Explicit Lock）以及原子变量。
线程安全的程序是否完全由线程安全类构成？答案是否定的，完全由线程安全类构成的程序并不一定就是线程安全的，而在线程安全类中也可以包含非线程安全的类。
### 1、什么是线程安全
在线程安全性的定义中，最核心的概念就是正确性，正确性的定义是，某个类的行为和其规范是完全一致的。
当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么这个类就是线程安全的。同时，无状态的对象一定是线程安全的。
### 2、原子性
这里拿自增操作举例，在java中自增语句：++，自增的操作并不是一个原子操作，并不是一个单独的操作，他只是三个离散操作的间歇，首先是获取到变量的原值，然后加1，最后是写会新值。是一个读-改-写的操作，这就意味着，最终的结果依赖于他先前读的状态。例如有一个计数器的功能，我们没命中一次对操作加1，假如这个变量为i，初始值为0，有3个并发操作请求到，我们理想的结果应该是3，但是由于我们的自增并不是原子操作，所以3个请求可能在某一时刻同时拿到初始值0，然后加各自加1，最后的结果为1。当然，也存在不同的情况，这三个请求没有在同一时间拿到原始值，或者在统一时间里有3个请求拿到原始值，这些情况有很多。这种情况，我们有一个专业的名词来描述他们叫做竞态条件。
#### a、竞态条件
当竞态条件产生时，导致的结果是不可靠的，最常见的竞态条件就是先检查，再运行。所谓的检查再运行就是我们基于观察的结果，然后再去做一些事情，但是在我们观察的过程中，在这段时间内，我们得到的观察的结果已经无效了，从而导致错误。
#### b、惰性初始化中的竞态条件
检查再运行的另一个用法就是惰性初始化，所谓惰性初始化的目的就是延迟对象的初始化，直到程序使用他的时候再初始化，而且只初始化一次。
#### c、复合操作
在上述的操作中，都包含了一些列的操作，为了避免竞态条件发生，我们必须阻止其他线程对我们正在修改的变量进行操作，想要对我们操作的变量进行操作 ，必须在我们操作之前或者是我们的线程操作完成之后才可以进行。
#### d、原子变量
在java.util.concurrent.atomic包中包括了原子变量类，这些类用来实现数字和对象引用的原子状态的转化，把long类型的计数器替换为AtomicLong类型的，我们可以保证访问计数器状态的操作都是原子的，这样计数器线程安全的了。
### 3、加锁机制
在这里我们想一个问题就是，在我们的操作中，使用原子变量就意味着操作就是线程安全的吗？答案是否定的，假设我们有一个操作，要同时操作两个变量，即使这两个变量都是原子操作，我们也不能保证我们的这个函数一定是线程安全的，因为我们不能保证在对这两个变量set的时候是同时执行的。这种情况不适用于依赖于两个状态的变量。
#### a、内置锁
java提供了强制原子性的内置锁机制，synchronized快，一个synchronized块有两个部分：锁对象的引用，以及这个锁保护的代码块，synchronized方法是对跨越了整个方法体的synchronized块的简短描述，至于synchronized方法的锁，就是该方法所在对象本身，静态的synchronized方法从class对象获取锁。

synchronized（lock）{

    //访问或修改被锁保护的共享状态

}

### 4、用锁来保护状态
### 5、活跃性与性能
## 二、对象的共享
## 三、对象的组合
## 四、基础构建模块

