---
layout: post
title: java并发编程实践-基础知识!
date:  2019-09-14
Author: XKZ
categories: jekyll update
tags: [concurrency]
comments: true
---
## 一、线程安全性
在java同步机制中，同步的关键字是synchronized,它提供了一种独占的加锁方式，但是同步术语还包括volatile类型的变量，显式锁（Explicit Lock）以及原子变量。
线程安全的程序是否完全由线程安全类构成？答案是否定的，完全由线程安全类构成的程序并不一定就是线程安全的，而在线程安全类中也可以包含非线程安全的类。
### 1、什么是线程安全
在线程安全性的定义中，最核心的概念就是正确性，正确性的定义是，某个类的行为和其规范是完全一致的。
当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么这个类就是线程安全的。同时，无状态的对象一定是线程安全的。
### 2、原子性
这里拿自增操作举例，在java中自增语句：++，自增的操作并不是一个原子操作，并不是一个单独的操作，他只是三个离散操作的间歇，首先是获取到变量的原值，然后加1，最后是写会新值。是一个读-改-写的操作，这就意味着，最终的结果依赖于他先前读的状态。例如有一个计数器的功能，我们没命中一次对操作加1，假如这个变量为i，初始值为0，有3个并发操作请求到，我们理想的结果应该是3，但是由于我们的自增并不是原子操作，所以3个请求可能在某一时刻同时拿到初始值0，然后加各自加1，最后的结果为1。当然，也存在不同的情况，这三个请求没有在同一时间拿到原始值，或者在统一时间里有3个请求拿到原始值，这些情况有很多。这种情况，我们有一个专业的名词来描述他们叫做竞态条件。
#### a、竞态条件
当竞态条件产生时，导致的结果是不可靠的，最常见的竞态条件就是先检查，再运行。所谓的检查再运行就是我们基于观察的结果，然后再去做一些事情，但是在我们观察的过程中，在这段时间内，我们得到的观察的结果已经无效了，从而导致错误。
#### b、惰性初始化中的竞态条件
检查再运行的另一个用法就是惰性初始化，所谓惰性初始化的目的就是延迟对象的初始化，直到程序使用他的时候再初始化，而且只初始化一次。
#### c、复合操作
在上述的操作中，都包含了一些列的操作，为了避免竞态条件发生，我们必须阻止其他线程对我们正在修改的变量进行操作，想要对我们操作的变量进行操作 ，必须在我们操作之前或者是我们的线程操作完成之后才可以进行。
#### d、原子变量
在java.util.concurrent.atomic包中包括了原子变量类，这些类用来实现数字和对象引用的原子状态的转化，把long类型的计数器替换为AtomicLong类型的，我们可以保证访问计数器状态的操作都是原子的，这样计数器线程安全的了。
### 3、加锁机制
在这里我们想一个问题就是，在我们的操作中，使用原子变量就意味着操作就是线程安全的吗？答案是否定的，假设我们有一个操作，要同时操作两个变量，即使这两个变量都是原子操作，我们也不能保证我们的这个函数一定是线程安全的，因为我们不能保证在对这两个变量set的时候是同时执行的。这种情况不适用于依赖于两个状态的变量。
#### a、内置锁
java提供了强制原子性的内置锁机制，synchronized块，一个synchronized块有两个部分：锁对象的引用，以及这个锁保护的代码块，synchronized方法是对跨越了整个方法体的synchronized块的简短描述，至于synchronized方法的锁，就是该方法所在对象本身，静态的synchronized方法从class对象获取锁。

synchronized（lock）{

    //访问或修改被锁保护的共享状态

}

在Java中，每个对象都可以隐式的扮演一个用于同步的锁的角色，这些内置的锁称为内置锁或是监视器锁，执行线程进入synchronized块之前会自动获取锁，而无论通过正常路径退出还是从块代码中抛出异常退出，线程都在放弃对synchronized控制时释放锁。
获得锁的唯一途径就是进入这个内置锁保护的同步块或者是方法。
由于在同一个时间内只有一个线程可以运行持有锁保护的代码块，所以有一个锁保护的操作会按照原子执行，不会互相干扰。
#### b、重进入
当一个线程请求其他线程已经占有的锁时，请求线程会被阻塞，但是对于内置锁，却是可以重入的，因此线程在试图获得他自己占有的锁时，会请求成功。
重进入的实现是通过每个锁关联一个请求计数和一个占有他的线程，当计数为0的时候，意味着这个锁没有呗占用，线程请求一个没有没占用的锁的时候，jvm将锁记录为战友，并且将请求计数置为1.如果同一个线程再次请求这个锁，计数增加，每次占用线程退出同步块，计数器会将值递减，知道计数器为0。
重进入的锁方便了锁行为的封装，当一个子类覆写了父类的synchronized类型的方法时，并调用了父类的synchronized方法，如果没有重入锁，就会导致死锁。
### 4、用锁来保护状态
有了锁，线程就可以穿行的执行它所保护的代码路径。
操作共享状态的复合操作必须是原子的，以避免竞态条件，比如递增计数器，或者是惰性初始化等。
### 5、活跃性与性能
## 二、对象的共享
## 三、对象的组合
## 四、基础构建模块

