---
layout: post
title: JVM学习（三）内存分配机制
date:  2020-11-21
Author: XKZ
categories: jekyll update
tags: [JVM]
comments: true
---
# 一、JVM对象创建过程
![img](https://xukaizhong188.github.io/HelloProgrammer/images/2020-11-21/p8.png)
对象创建就是new一个对象，对应执行new指令。
### 1.1类加载检查
虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
new指令对应到语言层面上讲是，new关键词、对象克隆、对象序列化等。
### 1.2分配内存
#### 1.2.1、划分多大的内存？
对象所需要的大小在加载的时候已经完全确定，为对象分配内存空间实际上就是需要将一块确定大小的空间从堆中划分出来
#### 1.2.2、如何划分？
##### 方法一：指针碰撞（默认方法）
如果Java堆内存是绝对规整的（规整的标准：所有用过的内存都放在一边，未用过的放在了另一边），在使用和未使用的空间中间有一个指针，作为指示器，那所分配的内存就是需要将这个指针向空闲区域挪动和对象大小相等的区域
##### 方法二：空闲列表
如果Java堆内存是非规整的，已使用的内存和未使用的内存是错乱的，这个时候就需要维护一个列表，记录那些内存块是可以用的，在分配的时候红列表中找到一块足够大的空间划分给对象。
#### 1.2.3、在并发情况下，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来争抢内存的情况，如何解决？
##### 方法一：CAS
虚拟机会采用CAS+失败重试的方式来保证更新操作的原子性来对分配空间的动作进行同步处理。大家同时去抢同一个空间，谁抢到谁算
##### 方法二：本地线程分配缓存TLAB
把内存分配的动作按照线程划分在不同空间之间进行，也就是每个线程在Java堆中预先分配一块空间。Java8默认使用这种方式使用-XX:+/ -UseTLAB来设置是否使用TLAB    
­XX:TLABSize 指定TLAB大小。
### 1.3初始化
内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)， 如果使用TLAB，这一工作过程也 可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问 到这些字段的数据类型所对应的零值。
### 1.4设置对象头
初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对 象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头Object Header之中。   
在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域:对象头(Header)、 实例数据(Instance Data) 和对齐填充(Padding)。    
### 1.5执行init方法
为对象进行真正的赋值，并执行构造方法
# 二、对象头与指针
![img](https://xukaizhong188.github.io/HelloProgrammer/images/2020-11-21/p9.png)
## 2.1、对象头 
HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。      
对象头的另外一部分 是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
## 2.2、对象大小
对象大小可以用jol­core包查看，引入依赖
````
<dependency>
    <groupId>org.openjdk.jol</groupId> 
    <artifactId>jol‐core</artifactId>
    <version>0.9</version>
</dependency>     
      
````
## 2.3、指针压缩
1.jdk1.6 update14开始，在64bit操作系统中，JVM支持指针压缩       
2.jvm配置参数:UseCompressedOops，compressed­­压缩、oop(ordinary object pointer)­­对象指针        
3.启用指针压缩:­XX:+UseCompressedOops(默认开启)，禁止指针压缩:­XX:­UseCompressedOops   
###### 为什么要进行指针压缩?  
1.在64位平台的HotSpot中使用32位指针，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据， 占用较大宽带，同时GC也会承受较大压力    
2.为了减少64位平台下内存的消耗，启用指针压缩功能     
3.在jvm中，32位地址最大支持4G内存(2的32次方)，可以通过对对象指针的压缩编码、解码方式进行优化，使得jvm 只用32位地址就可以支持更大的内存配置(小于等于32G)        
4.堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间       
5.堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，所以堆内 存不要大于32G为好  

# 三、JVM对象内存分配
一个对象创建时候的分配流程大致如下图：      
首先对象会判断是否可以在栈上进行分配，如果可以该对象会存放在栈内存中；   
如果不能在栈内存分配那么jvm会判断该对象是否非大对象如果是大对象将直接分配在老年代，
![img](https://xukaizhong188.github.io/HelloProgrammer/images/2020-11-23/p1.jpeg)

# 四、逃逸分析&栈上分配&标量替换
## 4.1、创建对象时的逃逸分析
### 4.1.1、什么是逃逸分析
逃逸分析就是对对象的作用域进行分析，如果一个对象在一个对象中定义后，可能会被其他方法引用，那么这个对象就是逃逸；    
例如：
````
public void test(){
    User user = new User();
    user.setName("xx");
}
````
test方法中的user对象只在该方法中使用，并未被其他方法引用，此时user对象就是无逃逸状态，再看test2方法：
````
public User test2(){
    User user = new User();
    user.setName("xx");
    returr user;
}
````
在test2中，user对象作为返回对象被放回，当有外部对象方法调用test2时此时user就产生了逃逸。
### 4.1.2、为什么要有逃逸分析
我们都知道对象的创建都是在堆内存上进行分配的，当对象没有引用的时候都是依赖gc来进行对象的回收，JVM会对一些临时使用的对象进行逃逸分析，将这些临时的对象分配到栈内存中；      
通过这些对象会跟随方法执行完成栈帧的回收而被销毁。
## 4.2、栈上分配
通过逃逸分析，当jvm发现一个对象没有发生逃逸时候，此时jvm会在栈上进行对象的内存分配，在jdk7以后逃逸分析是默认开启的。
## 4.3、标量替换
当对象没有发生逃逸，没有被外部方法访问时，且对象可以分解的时候，jvm此时并不会创建该对象，会通过标量替换的方式来将对象的成员变量分解成多个被方法引用的成员变量存储在栈上或者是寄存器上。这样就会避免在栈上分配内存的时候因没有连续空间而无法分配的问题。
### 4.3.1、标量
标量即不可拆分的量，例如Java的基本数据类型
### 4.3.2、聚合量
标量的对立的量
# 五、对象在堆上的分配
## 5.1、在Eden上
大量的对象被分配在eden区，eden区满了后会触发minor gc，可能会有99%以上的对象成为垃圾被回收掉，剩余存活 的对象会被挪到为空的那块survivor区，下一次eden区满了后又会触发minor gc，把eden区和survivor区垃圾对象回收，把剩余存活的对象一次性挪动到另外一块为空的survivor区；    
因为新生代的对象都是朝生夕死，存活时间很短，所以JVM默认的8:1:1的比例是很合适的，让eden区尽量的大，survivor区够用即可。   
## 5.2、大对象直接进入老年代
大对象就是需要大量连续内存空间的对象(比如:字符串、数组)。JVM参数 -XX:PretenureSizeThreshold 可以设置大 对象的大小，如果对象超过设置大小会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集器下 有效。   
比如设置JVM参数:-XX:PretenureSizeThreshold=1000000 (单位是字节) -XX:+UseSerialGC ，再执行下上面的第一 个程序会发现大对象直接进了老年代
为什么要这样呢?   
为了避免为大对象分配内存时的复制操作而降低效率。   
G1有自己的特定的大对象处理机制
## 5.2、长期存活的对象将会进入老年代
分代年龄
### 什么情况要设置分代年龄
如果代码中没有生存周期特别长的对象时需要设置此值。
## 5.3、对象动态年龄判断
当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的 50%(-XX:TargetSurvivorRatio可以指定)，那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了， 例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会 把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。对象动态年 龄判断机制一般是在minor gc之后触发的。
## 5.4、老年代空间分配担保机制
年轻代每次minor gc之前JVM都会计算下老年代剩余可用空间 如果这个可用空间小于年轻代里现有的所有对象大小之和(包括垃圾对象) 就会看一个“-XX:-HandlePromotionFailure”(jdk1.8默认就设置了)的参数是否设置了 如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor gc后进入老年代的对象的平均大小。 如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full gc，对老年代和年轻代一起回收一次垃圾， 如果回收完还是没有足够空间存放新的对象就会发生"OOM"
当然，如果minor gc之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发full gc，full gc完之后如果还是没有空间放minor gc之后的存活对象，则也会发生“OOM”
![img](https://xukaizhong188.github.io/HelloProgrammer/images/2020-11-24/p1.jpg)
# 七、对象内存回收
判断一个对象是否会被分析
## 7.1、可达性分析算法
将“GC Roots” 对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为非垃圾对象，其余未标记的    
对象都是垃圾对象    
GC Roots根节点:线程栈的本地变量、静态变量、本地方法栈的变量等等
## 7.2、引用计数法
给一个对象会加一个计数器，如果有一个地方引用，计数器就会加1；当引用失效，计数器就会减1，当计数器为0的时候就代表这个对象没有被引用。    
这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决 对象之间相互循环引用的问题。     
例如：
````
A a = new A();//计数器为1
B b = new B();//计数器为1
a.b = b;//计数器为2
b.a = a;//计数器为2
a = null;//计数器为1
b = null;//计数器为1
````
实际上以上的ab对象都无引用，但是由于中间发生了互相引用，导致无法通知垃圾回收器进行通知。
# 八、日均百万级订单交易系统JVM参数设置实例
4核8G的服务器：   
设置元空间大小：    
300qps会创建300个线程，会有300个对象产生，
估算每秒有多少大小的内存分配放在eden