---
layout: post
title: JVM学习（三）内存分配机制
date:  2020-11-21
Author: XKZ
categories: jekyll update
tags: [JVM]
comments: true
---
# 一、JVM对象创建过程
![img](https://xukaizhong188.github.io/HelloProgrammer/images/2020-11-21/p8.png)
对象创建就是new一个对象，对应执行new指令。
### 1.1类加载检查
虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
new指令对应到语言层面上讲是，new关键词、对象克隆、对象序列化等。
### 1.2分配内存
#### 1.2.1、划分多大的内存？
对象所需要的大小在加载的时候已经完全确定，为对象分配内存空间实际上就是需要将一块确定大小的空间从堆中划分出来
#### 1.2.2、如何划分？
##### 方法一：指针碰撞（默认方法）
如果Java堆内存是绝对规整的（规整的标准：所有用过的内存都放在一边，未用过的放在了另一边），在使用和未使用的空间中间有一个指针，作为指示器，那所分配的内存就是需要将这个指针向空闲区域挪动和对象大小相等的区域
##### 方法二：空闲列表
如果Java堆内存是非规整的，已使用的内存和未使用的内存是错乱的，这个时候就需要维护一个列表，记录那些内存块是可以用的，在分配的时候红列表中找到一块足够大的空间划分给对象。
#### 1.2.3、在并发情况下，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来争抢内存的情况，如何解决？
##### 方法一：CAS
虚拟机会采用CAS+失败重试的方式来保证更新操作的原子性来对分配空间的动作进行同步处理。大家同时去抢同一个空间，谁抢到谁算
##### 方法二：本地线程分配缓存
把内存分配的动作按照线程划分在不同空间之间进行，也就是每个线程在Java堆中预先分配一块空间。Java8默认使用这种方式使用-XX:+/ -UseTLAB来设置是否使用TLAB    
­XX:TLABSize 指定TLAB大小。
### 1.3初始化
内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)， 如果使用TLAB，这一工作过程也 可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问 到这些字段的数据类型所对应的零值。
### 1.4设置对象头
初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对 象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头Object Header之中。   
在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域:对象头(Header)、 实例数据(Instance Data) 和对齐填充(Padding)。    
### 1.5执行init方法
为对象进行真正的赋值，并执行构造方法
# 二、对象头与指针
![img](https://xukaizhong188.github.io/HelloProgrammer/images/2020-11-21/p9.png)
## 2.1、对象头 
HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。      
对象头的另外一部分 是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
## 2.2、对象大小
对象大小可以用jol­core包查看，引入依赖
````
<dependency>
    <groupId>org.openjdk.jol</groupId> 
    <artifactId>jol‐core</artifactId>
    <version>0.9</version>
</dependency>     
      
````
## 2.3、指针压缩
1.jdk1.6 update14开始，在64bit操作系统中，JVM支持指针压缩       
2.jvm配置参数:UseCompressedOops，compressed­­压缩、oop(ordinary object pointer)­­对象指针        
3.启用指针压缩:­XX:+UseCompressedOops(默认开启)，禁止指针压缩:­XX:­UseCompressedOops   
###### 为什么要进行指针压缩?  
1.在64位平台的HotSpot中使用32位指针，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据， 占用较大宽带，同时GC也会承受较大压力    
2.为了减少64位平台下内存的消耗，启用指针压缩功能     
3.在jvm中，32位地址最大支持4G内存(2的32次方)，可以通过对对象指针的压缩编码、解码方式进行优化，使得jvm 只用32位地址就可以支持更大的内存配置(小于等于32G)        
4.堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间       
5.堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，所以堆内 存不要大于32G为好  

# 三、JVM对象内存分配
一个对象创建时候的分配流程大致如下图：      
首先对象会判断是否可以在栈上进行分配，如果可以该对象会存放在栈内存中；   
如果不能在栈内存分配那么jvm会判断该对象是否非大对象如果是大对象将直接分配在老年代，
![img](https://xukaizhong188.github.io/HelloProgrammer/images/2020-11-23/p1.jpeg)

# 四、逃逸分析&栈上分配&标量替换
## 4.1、创建对象时的逃逸分析
### 4.1.1、什么是逃逸分析
逃逸分析就是对对象的作用域进行分析，如果一个对象在一个对象中定义后，可能会被其他方法引用，那么这个对象就是逃逸；    
例如：
````
public void test(){
    User user = new User();
    user.setName("xx");
}
````
test方法中的user对象只在该方法中使用，并未被其他方法引用，此时user对象就是无逃逸状态，再看test2方法：
````
public User test2(){
    User user = new User();
    user.setName("xx");
    returr user;
}
````
在test2中，user对象作为返回对象被放回，当有外部对象方法调用test2时此时user就产生了逃逸。
### 4.1.2、为什么要有逃逸分析
我们都知道对象的创建都是在堆内存上进行分配的，当对象没有引用的时候都是依赖gc来进行对象的回收，JVM会对一些临时使用的对象进行逃逸分析，将这些临时的对象分配到栈内存中；      
通过这些对象会跟随方法执行完成栈帧的回收而被销毁。
## 4.2、栈上分配
通过逃逸分析，当jvm发现一个对象没有发生逃逸时候，此时jvm会在栈上进行对象的内存分配，在jdk7以后逃逸分析是默认开启的。
## 4.3、标量替换
当对象没有发生逃逸，没有被外部方法访问时，且对象可以分解的时候，jvm此时并不会创建该对象，会通过标量替换的方式来将对象的成员变量分解成多个被方法引用的成员变量存储在栈上或者是寄存器上。这样就会避免在栈上分配内存的时候因没有连续空间而无法分配的问题。
### 4.3.1、标量
标量即不可拆分的量，例如Java的基本数据类型
### 4.3.2、聚合量
标量的对立的量
# 五、对象内存回收机制
# 六、日均百万级订单交易系统JVM参数设置实例