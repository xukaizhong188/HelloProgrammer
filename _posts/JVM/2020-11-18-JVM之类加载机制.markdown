---
layout: post
title: 类加载机制解析
date:  2020-11-18
Author: XKZ
categories: jekyll update
tags: [JVM]
comments: true
---
# 一、从java.exe开始认识Java类加载运行全过程
![img](https://xukaizhong188.github.io/HelloProgrammer/images/2020-11-18/p1.png)
一个类在windows下会先创建Java虚拟机；   
然后会创建一个引导类加载器实例；   
C++会调用Java代码创建JVM启动器实例sun.misc.Launcher（引导类加载器负责加载创建其他类加载器）；   


## 1、类加载的过程：  
加载  验证  准备   解析  初始化   使用  卸载
### 1.1、加载
在硬盘上查找并通过io读入字节码文件,并生成一个对应的class文件
### 1.2、验证
验证字节码文件的正确性
### 1.3、准备
给类的静态变量分配内存并赋予默认值，此值和最终值无关系（加载过程中），常量会直接赋值
### 1.4、解析
将符号引用替换为直接引用，该阶段会把一些静态方法(符号引用，比如main()方法)替换为指向数据所存内存的指针或句柄等(直接引用)，这是所谓的静态链接过 程(类加载期间完成)，动态链接是在程序运行期间完成的将符号引用替换为直接引用。
    符号引用：
    直接引用：
### 1.5、初始化
对静态变量初始化为指定的值，执行静态代码块
### 1.6、使用

### 1.7、卸载：


类被加载到方法区后主要包含运行时常量池、类型信息、字段信息、方法信息、类加载器的引用、对应class实例的引用等信息  

类加载是一种懒加载（只有在用到的时候才会加载）

## 2、类加载器classloader
引导类：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如 rt.jar、charsets.jar等  
扩展类：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR 类包  
应用程序类：负责加载ClassPath路径下的类包，主要就是加载你自己写的那 些类  
自定义加载器：负责加载用户自定义路径下的类包  
## 3、类加载的双亲委派机制：
![img](https://xukaizhong188.github.io/HelloProgrammer/images/2020-11-21/p1.jpg)

### 3.1、什么是双亲委派机制
在加载一个类的时候，会先使用他的上级加载器加载此类，进行向上委托，父加载器加载失败会交给子加载器。
### 3.2、为什么从应用程序类加载而不是从引导类开始  
launcher类会调用getClassLoader 返回load,这个在初始化的时候 会最先返回appclassLoad,JVM源码就是这样实现的  
其实在实际运用过程中95%的类都是自己开发的类，那么在第一次加载的时候，利用双亲委派即可加载到所有的类的，这样在后续使用过程中直接使用即可，如果从引导类开始加载，那么每次都需要从引导类开始。
### 3.3、加载的过程
先判断此类是否加载过findLoaderClass,如果加载过直接返回，不再进行加载；
如果为空则会判断父加载器是否为空，如果不为空委派给父加载器，直到父加载器为空，会调用引导类加载器加载此类，
当引导类加载器能加载到此类，则返回，
如果没加载到返回上一层即子加载器直到加载到想要加载的类。
### 3.4、为什么要设计双亲委派机制
沙箱安全机制：自己实现的jdk源码的核心类库，是无法被加载的，保证核心类库不被篡改；   
避免类的重复加载:当父加载器加载了类后，就没必要交由子加载器加载,保证加载过程的唯一性。

双亲委派核心实现在ClassLoader中的loadClass方法

## 4、全盘负责委托机制
当一个加载器加载一个类的时候，除非是显示的使用另一种加载器，否则的话这个类所依赖的类也会用同一个加载器去加载，比如自定义一个Main类，在加载这个类的时候回使用AppClassLoad，同时Main类依赖了
User类，那么在加载User类时也会使用AppClassLoad加载完成。
## 5、自定义加载器示例：
自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是 loadClass(String, boolean)，实现了双亲委派机制，还有一个方法是findClass，默认实现是空 方法，
所以我们自定义类加载器主要是重写 方法。
````

````

# 二、从JDK源码级别剖析JVM核心类加载器
# 三、手写自定义类加载器打破双亲委派机制
# 四、Tomcat类加载机制深度剖析
# 五、手写Tomcat类加载器实现多版本代码共存隔离

# 六、附录
Javap -v xx.class