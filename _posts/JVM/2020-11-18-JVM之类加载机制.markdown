---
layout: post
title: 类加载机制解析
date:  2020-11-18
Author: XKZ
categories: jekyll update
tags: [JVM]
comments: true
---
# 一、从java.exe开始认识Java类加载运行全过程
![img](https://xukaizhong188.github.io/HelloProgrammer/images/2020-11-18/p1.png)
一个类在windows下会先创建Java虚拟机；   
然后会创建一个引导类加载器实例；   
C++会调用Java代码创建JVM启动器实例sun.misc.Launcher（引导类加载器负责加载创建其他类加载器）；   


## 1、类加载的过程：  
加载  验证  准备   解析  初始化   使用  卸载
### 1.1、加载
在硬盘上查找并通过io读入字节码文件,并生成一个对应的class文件
### 1.2、验证
验证字节码文件的正确性
### 1.3、准备
给类的静态变量分配内存并赋予默认值，此值和最终值无关系（加载过程中），常量会直接赋值
### 1.4、解析
将符号引用替换为直接引用，该阶段会把一些静态方法(符号引用，比如main()方法)替换为指向数据所存内存的指针或句柄等(直接引用)，这是所谓的静态链接过 程(类加载期间完成)，动态链接是在程序运行期间完成的将符号引用替换为直接引用。
    符号引用：
    直接引用：
### 1.5、初始化
对静态变量初始化为指定的值，执行静态代码块
### 1.6、使用

### 1.7、卸载：


类被加载到方法区后主要包含运行时常量池、类型信息、字段信息、方法信息、类加载器的引用、对应class实例的引用等信息  

类加载是一种懒加载（只有在用到的时候才会加载）

## 2、类加载器classloader
引导类：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如 rt.jar、charsets.jar等  
扩展类：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR 类包  
应用程序类：负责加载ClassPath路径下的类包，主要就是加载你自己写的那 些类  
自定义加载器：负责加载用户自定义路径下的类包  
## 3、类加载的双亲委派机制：




# 二、从JDK源码级别剖析JVM核心类加载器
# 三、手写自定义类加载器打破双亲委派机制
# 四、Tomcat类加载机制深度剖析
# 五、手写Tomcat类加载器实现多版本代码共存隔离

# 六、附录
Javap -v xx.class